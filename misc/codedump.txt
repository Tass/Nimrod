
Const
  PriorityConstants : Array [TProcessPriority] of Cardinal =
                      (HIGH_PRIORITY_CLASS,IDLE_PRIORITY_CLASS,
                       NORMAL_PRIORITY_CLASS,REALTIME_PRIORITY_CLASS);

procedure TProcess.CloseProcessHandles;
begin
  if (FProcessHandle<>0) then
    CloseHandle(FProcessHandle);
  if (FThreadHandle<>0) then
    CloseHandle(FThreadHandle);
end;

Function TProcess.PeekExitStatus : Boolean;

begin
  GetExitCodeProcess(ProcessHandle,FExitCode);
  Result:=(FExitCode<>Still_Active);
end;

Function GetStartupFlags (P : TProcess): Cardinal;

begin
  With P do
    begin
    Result:=0;
    if poUsePipes in FProcessOptions then
       Result:=Result or Startf_UseStdHandles;
    if suoUseShowWindow in FStartupOptions then
      Result:=Result or startf_USESHOWWINDOW;
    if suoUSESIZE in FStartupOptions then
      Result:=Result or startf_usesize;
    if suoUsePosition in FStartupOptions then
      Result:=Result or startf_USEPOSITION;
    if suoUSECOUNTCHARS in FStartupoptions then
      Result:=Result or startf_usecountchars;
    if suoUsefIllAttribute in FStartupOptions then
      Result:=Result or startf_USEFILLATTRIBUTE;
    end;
end;

Function GetCreationFlags(P : TProcess) : Cardinal;

begin
  With P do
    begin
    Result:=0;
    if poNoConsole in FProcessOptions then
      Result:=Result or Detached_Process;
    if poNewConsole in FProcessOptions then
      Result:=Result or Create_new_console;
    if poNewProcessGroup in FProcessOptions then
      Result:=Result or CREATE_NEW_PROCESS_GROUP;
    If poRunSuspended in FProcessOptions Then
      Result:=Result or Create_Suspended;
    if poDebugProcess in FProcessOptions Then
      Result:=Result or DEBUG_PROCESS;
    if poDebugOnlyThisProcess in FProcessOptions Then
      Result:=Result or DEBUG_ONLY_THIS_PROCESS;
    if poDefaultErrorMode in FProcessOptions Then
      Result:=Result or CREATE_DEFAULT_ERROR_MODE;
    result:=result or PriorityConstants[FProcessPriority];
    end;
end;

Function StringsToPChars(List : TStrings): pointer;

var
  EnvBlock: string;
  I: Integer;

begin
  EnvBlock := '';
  For I:=0 to List.Count-1 do
    EnvBlock := EnvBlock + List[i] + #0;
  EnvBlock := EnvBlock + #0;
  GetMem(Result, Length(EnvBlock));
  CopyMemory(Result, @EnvBlock[1], Length(EnvBlock));
end;

Procedure InitProcessAttributes(P : TProcess; Var PA : TSecurityAttributes);

begin
  FillChar(PA,SizeOf(PA),0);
  PA.nLength := SizeOf(PA);
end;

Procedure InitThreadAttributes(P : TProcess; Var TA : TSecurityAttributes);

begin
  FillChar(TA,SizeOf(TA),0);
  TA.nLength := SizeOf(TA);
end;

Procedure InitStartupInfo(P : TProcess; Var SI : STARTUPINFO);

Const
  SWC : Array [TShowWindowOptions] of Cardinal =
             (0,SW_HIDE,SW_Maximize,SW_Minimize,SW_Restore,SW_Show,
             SW_ShowDefault,SW_ShowMaximized,SW_ShowMinimized,
               SW_showMinNOActive,SW_ShowNA,SW_ShowNoActivate,SW_ShowNormal);

begin
  FillChar(SI,SizeOf(SI),0);
  With SI do
    begin
    dwFlags:=GetStartupFlags(P);
    if P.FShowWindow<>swoNone then
     dwFlags:=dwFlags or Startf_UseShowWindow
    else
      dwFlags:=dwFlags and not Startf_UseShowWindow;
    wShowWindow:=SWC[P.FShowWindow];
    if (poUsePipes in P.Options) then
      begin
      dwFlags:=dwFlags or Startf_UseStdHandles;
      end;
    if P.FillAttribute<>0 then
      begin
      dwFlags:=dwFlags or Startf_UseFillAttribute;
      dwFillAttribute:=P.FillAttribute;
      end;
     dwXCountChars:=P.WindowColumns;
     dwYCountChars:=P.WindowRows;
     dwYsize:=P.WindowHeight;
     dwXsize:=P.WindowWidth;
     dwy:=P.WindowTop;
     dwX:=P.WindowLeft;
     end;
end;

Procedure CreatePipes(Var HI,HO,HE : Thandle; Var SI : TStartupInfo; CE : Boolean);

  Procedure DoCreatePipeHandles(Var H1,H2 : THandle);

  Var
    I,O : Longint;

  begin
    CreatePipeHandles(I,O);
    H1:=Thandle(I);
    H2:=THandle(O);
  end;




begin
  DoCreatePipeHandles(SI.hStdInput,HI);
  DoCreatePipeHandles(HO,Si.hStdOutput);
  if CE then
    DoCreatePipeHandles(HE,SI.hStdError)
  else
    begin
    SI.hStdError:=SI.hStdOutput;
    HE:=HO;
    end;
end;


Procedure TProcess.Execute;


Var
  PName,PDir,PCommandLine : PChar;
  FEnv: pointer;
  FCreationFlags : Cardinal;
  FProcessAttributes : TSecurityAttributes;
  FThreadAttributes : TSecurityAttributes;
  FProcessInformation : TProcessInformation;
  FStartupInfo : STARTUPINFO;
  HI,HO,HE : THandle;

begin
  FInheritHandles:=True;
  PName:=Nil;
  PCommandLine:=Nil;
  PDir:=Nil;
  If FApplicationName<>'' then
    PName:=Pchar(FApplicationName);
  If FCommandLine<>'' then
    PCommandLine:=Pchar(FCommandLine);
  If FCurrentDirectory<>'' then
    PDir:=Pchar(FCurrentDirectory);
  if FEnvironment.Count<>0 then
    FEnv:=StringsToPChars(FEnvironment)
  else
    FEnv:=Nil;
  Try
    FCreationFlags:=GetCreationFlags(Self);
    InitProcessAttributes(Self,FProcessAttributes);
    InitThreadAttributes(Self,FThreadAttributes);
    InitStartupInfo(Self,FStartUpInfo);
    If poUsePipes in FProcessOptions then
      CreatePipes(HI,HO,HE,FStartupInfo,Not(poStdErrToOutPut in FProcessOptions));
    Try
      If Not CreateProcess (PName,PCommandLine,@FProcessAttributes,@FThreadAttributes,
                   FInheritHandles,FCreationFlags,FEnv,PDir,FStartupInfo,
                   fProcessInformation) then
        Raise Exception.CreateFmt('Failed to execute %s : %d',[FCommandLine,GetLastError]);
      FProcessHandle:=FProcessInformation.hProcess;
      FThreadHandle:=FProcessInformation.hThread;
      FProcessID:=FProcessINformation.dwProcessID;
    Finally
      if POUsePipes in FProcessOptions then
        begin
        FileClose(FStartupInfo.hStdInput);
        FileClose(FStartupInfo.hStdOutput);
        if Not (poStdErrToOutPut in FProcessOptions) then
          FileClose(FStartupInfo.hStdError);
        CreateStreams(HI,HO,HE);
        end;
    end;
    FRunning:=True;
  Finally
    If FEnv<>Nil then
      FreeMem(FEnv);
  end;
  if not (csDesigning in ComponentState) and // This would hang the IDE !
     (poWaitOnExit in FProcessOptions) and
      not (poRunSuspended in FProcessOptions) then
    WaitOnExit;
end;

Function TProcess.WaitOnExit : Dword;

begin
  Result:=WaitForSingleObject (FProcessHandle,Infinite);
  If Result<>Wait_Failed then
    GetExitStatus;
  FRunning:=False;
end;

Function TProcess.Suspend : Longint;

begin
  Result:=SuspendThread(ThreadHandle);
end;

Function TProcess.Resume : LongInt;

begin
  Result:=ResumeThread(ThreadHandle);
end;

Function TProcess.Terminate(AExitCode : Integer) : Boolean;

begin
  Result:=False;
  If ExitStatus=Still_active then
    Result:=TerminateProcess(Handle,AexitCode);
end;

Procedure TProcess.SetShowWindow (Value : TShowWindowOptions);


begin
  FShowWindow:=Value;
end;

// ---------------------------- end of platform dependant code --------------

{
  Unix Process .inc.
}

uses
   Unix,
   Baseunix;



Const
  PriorityConstants : Array [TProcessPriority] of Integer =
                      (20,20,0,-20);

Const
  GeometryOption : String = '-geometry';
  TitleOption : String ='-title';



procedure TProcess.CloseProcessHandles;

begin
 // Do nothing. Win32 call.
end;

Function TProcess.PeekExitStatus : Boolean;

begin
  Result:=fpWaitPid(Handle,@FExitCode,WNOHANG)=Handle;
  If Result then
    FExitCode:=wexitstatus(FExitCode)
  else
    FexitCode:=0;
end;

Type
  TPCharArray = Array[Word] of pchar;
  PPCharArray = ^TPcharArray;

Function StringsToPCharList(List : TStrings) : PPChar;

Var
  I : Integer;
  S : String;

begin
  I:=(List.Count)+1;
  GetMem(Result,I*sizeOf(PChar));
  PPCharArray(Result)^[List.Count]:=Nil;
  For I:=0 to List.Count-1 do
    begin
    S:=List[i];
    Result[i]:=StrNew(PChar(S));
    end;
end;

Procedure FreePCharList(List : PPChar);

Var
  I : integer;

begin
  I:=0;
  While List[i]<>Nil do
    begin
    StrDispose(List[i]);
    Inc(I);
    end;
  FreeMem(List);
end;


Procedure CommandToList(S : String; List : TStrings);

  Function GetNextWord : String;

  Const
    WhiteSpace = [' ',#8,#10];
    Literals = ['"',''''];

  Var
    Wstart,wend : Integer;
    InLiteral : Boolean;
    LastLiteral : char;

  begin
    WStart:=1;
    While (WStart<=Length(S)) and (S[WStart] in WhiteSpace) do
      Inc(WStart);
    WEnd:=WStart;
    InLiteral:=False;
    LastLiteral:=#0;
    While (Wend<=Length(S)) and (Not (S[Wend] in WhiteSpace) or InLiteral) do
      begin
      if S[Wend] in Literals then
        If InLiteral then
          InLiteral:=Not (S[Wend]=LastLiteral)
        else
          begin
          InLiteral:=True;
          LastLiteral:=S[Wend];
          end;
       inc(wend);
       end;
     Result:=Copy(S,WStart,WEnd-WStart);
     Result:=StringReplace(Result,'"','',[rfReplaceAll]);
     Result:=StringReplace(Result,'''','',[rfReplaceAll]);
     While (WEnd<=Length(S)) and (S[Wend] in WhiteSpace) do
       inc(Wend);
     Delete(S,1,WEnd-1);

  end;

Var
  W : String;

begin
  While Length(S)>0 do
    begin
    W:=GetNextWord;
    If (W<>'') then
      List.Add(W);
    end;
end;


Function MakeCommand(P : TProcess) : PPchar;

Const
  SNoCommandLine = 'Cannot execute empty command-line';

Var
  Cmd : String;
  S  : TStringList;
  G : String;

begin
  if (P.ApplicationName='') then
    begin
    If (P.CommandLine='') then
      Raise Exception.Create(SNoCommandline);
    Cmd:=P.CommandLine;
    end
  else
    begin
    If (P.CommandLine='') then
      Cmd:=P.ApplicationName
    else
      Cmd:=P.CommandLine;
    end;
  S:=TStringList.Create;
  try
    CommandToList(Cmd,S);
    if poNewConsole in P.Options then
      begin
      S.Insert(0,'-e');
      If (P.ApplicationName<>'') then
        begin
        S.Insert(0,P.ApplicationName);
        S.Insert(0,'-title');
        end;
      if suoUseCountChars in P.StartupOptions then
        begin
        S.Insert(0,Format('%dx%d',[P.dwXCountChars,P.dwYCountChars]));
        S.Insert(0,'-geometry');
        end;
      S.Insert(0,'xterm');
      end;
    if (P.ApplicationName<>'') then
      begin
      S.Add(TitleOption);
      S.Add(P.ApplicationName);
      end;
    G:='';
    if (suoUseSize in P.StartupOptions) then
      g:=format('%dx%d',[P.dwXSize,P.dwYsize]);
    if (suoUsePosition in P.StartupOptions) then
      g:=g+Format('+%d+%d',[P.dwX,P.dwY]);
    if G<>'' then
      begin
      S.Add(GeometryOption);
      S.Add(g);
      end;
    Result:=StringsToPcharList(S);
  Finally
    S.free;
  end;
end;

Function GetLastError : Integer;

begin
  Result:=-1;
end;

Type
  TPipeEnd = (peRead,peWrite);
  TPipePair = Array[TPipeEnd] of Integer;

Procedure CreatePipes(Var HI,HO,HE : TPipePair; CE : Boolean);

  Procedure CreatePair(Var P : TPipePair);

   begin
    If not CreatePipeHandles(P[peRead],P[peWrite]) then
      Raise Exception.Create('Failed to create pipes');
   end;

  Procedure ClosePair(Var P : TPipePair);

  begin
    if (P[peRead]<>-1) then
      FileClose(P[peRead]);
    if (P[peWrite]<>-1) then
      FileClose(P[peWrite]);
  end;

begin
  HO[peRead]:=-1;HO[peWrite]:=-1;
  HI[peRead]:=-1;HI[peWrite]:=-1;
  HE[peRead]:=-1;HE[peWrite]:=-1;
  Try
    CreatePair(HO);
    CreatePair(HI);
    If CE then
      CreatePair(HE);
  except
    ClosePair(HO);
    ClosePair(HI);
    If CE then
      ClosePair(HE);
    Raise;
  end;
end;

Procedure TProcess.Execute;

Var
  HI,HO,HE : TPipePair;
  PID      : Longint;
  FEnv     : PPChar;
  Argv     : PPChar;
  fd       : Integer;
  PName    : String;

begin
  If (poUsePipes in FProcessOptions) then
    CreatePipes(HI,HO,HE,Not (poStdErrToOutPut in FProcessOptions));
  Try
    if FEnvironment.Count<>0 then
      FEnv:=StringsToPcharList(FEnvironment)
    else
      FEnv:=Nil;
    Try
      Argv:=MakeCommand(Self);
      Try
        If (Argv<>Nil) and (ArgV[0]<>Nil) then
          PName:=StrPas(Argv[0])
        else
          begin
          // This should never happen, actually.
          PName:=ApplicationName;
          If (PName='') then
            PName:=CommandLine;
          end;
        if (pos('/',PName)<>1) then
          PName:=FileSearch(Pname,fpgetenv('PATH'));
        Pid:=fpfork;
        if Pid<0 then
          Raise Exception.Create('Failed to Fork process');
        if (PID>0) then
          begin
          // Parent process. Copy process information.
          FProcessHandle:=PID;
          FThreadHandle:=PID;
          FProcessId:=PID;
          //FThreadId:=PID;
          end
        else
          begin
          { We're in the child }
          if (FCurrentDirectory<>'') then
             ChDir(FCurrentDirectory);
          if PoUsePipes in Options then
            begin
            fpdup2(HI[peRead],0);
            fpdup2(HO[peWrite],1);
            if (poStdErrToOutPut in Options) then
              fpdup2(HO[peWrite],2)
            else
              fpdup2(HE[peWrite],2);
            end
          else if poNoConsole in Options then
            begin
            fd:=FileOpen('/dev/null',fmOpenReadWrite);
            fpdup2(fd,0);
            fpdup2(fd,1);
            fpdup2(fd,2);
            end;
          if (poRunSuspended in Options) then
            sigraise(SIGSTOP);
          if FEnv<>Nil then
            fpexecve(PName,Argv,Fenv)
          else
            fpexecv(PName,argv);
          Halt(127);
          end
      Finally
        FreePcharList(Argv);
      end;
    Finally
      If (FEnv<>Nil) then
        FreePCharList(FEnv);
    end;
  Finally
    if POUsePipes in FProcessOptions then
      begin
      FileClose(HO[peWrite]);
      FileClose(HI[peRead]);
      if Not (poStdErrToOutPut in FProcessOptions) then
        FileClose(HE[peWrite]);
      CreateStreams(HI[peWrite],HO[peRead],HE[peRead]);
      end;
  end;
  FRunning:=True;
  if not (csDesigning in ComponentState) and // This would hang the IDE !
     (poWaitOnExit in FProcessOptions) and
      not (poRunSuspended in FProcessOptions) then
    WaitOnExit;
end;

Function TProcess.WaitOnExit : Dword;

begin
  Result:=fpWaitPid(Handle,@FExitCode,0);
  If Result=Handle then
    FExitCode:=WexitStatus(FExitCode);
  FRunning:=False;
end;

Function TProcess.Suspend : Longint;

begin
  If fpkill(Handle,SIGSTOP)<>0 then
    Result:=-1
  else
    Result:=1;
end;

Function TProcess.Resume : LongInt;

begin
  If fpKill(Handle,SIGCONT)<>0 then
    Result:=-1
  else
    Result:=0;
end;

Function TProcess.Terminate(AExitCode : Integer) : Boolean;

begin
  Result:=False;
  Result:=fpkill(Handle,SIGTERM)=0;
  If Result then
    begin
    If Running then
      Result:=fpkill(Handle,SIGKILL)=0;
    end;
  GetExitStatus;
end;

Procedure TProcess.SetShowWindow (Value : TShowWindowOptions);

begin
  FShowWindow:=Value;
end;

// ---------------------------------------------------------------------------


Constructor TProcess.Create (AOwner : TComponent);
begin
  Inherited;
  FProcessPriority:=ppNormal;
  FShowWindow:=swoNone;
  FInheritHandles:=True;
  FEnvironment:=TStringList.Create;
end;

Destructor TProcess.Destroy;

begin
  FEnvironment.Free;
  FreeStreams;
  CloseProcessHandles;
  Inherited Destroy;
end;

Procedure TProcess.FreeStreams;

  procedure FreeStream(var S: THandleStream);

  begin
    if (S<>Nil) then
      begin
      FileClose(S.Handle);
      FreeAndNil(S);
      end;
  end;

begin
  If FStdErrStream<>FOutputStream then
    FreeStream(FStdErrStream);
  FreeStream(FOutputStream);
  FreeStream(FInputStream);
end;


Function TProcess.GetExitStatus : Integer;

begin
  If FRunning then
    PeekExitStatus;
  Result:=FExitCode;
end;


Function TProcess.GetRunning : Boolean;

begin
  IF FRunning then
    FRunning:=Not PeekExitStatus;
  Result:=FRunning;
end;




SH_SCRIPT_TEMPLATE = r"""#! /bin/sh
# generated by koch.py

myccflags="-O3"
mylinkflags=""

# get OS
case `uname` in
linux* | Linux*) myos="linux" ;;
darwin* | Darwin*) myos="macosx" ;;
SunOS* | Solaris*) myos="solaris" ;;
*bsd* | *BSD*) myos="bsd" ;;
*) myos="unix" ;; # it is some kind of UNIX dammit
esac

echo "$myos detected"

# get architecture
case `uname -m` in
*64*) myarch="cpu64" ;;
i386* | i486* | i586* | i686*) myarch="i386" ;;
*) myarch="cpu32" ;;
esac

# get compiler
echo "checking for installed C compilers..."
mycc=${CC}
if [ "$mycc"="" ]; then
  if [ "gcc -v" ]; then
    mycc="gcc"
  elif [ "cc -v" ]; then
    mycc="cc"
  elif [ "tcc -v" ]; then
    mycc="tcc"
  elif [ "icc -v" ]; then
    mycc="icc"
  else
    echo "cannot determine C compiler!"
    exit
  fi
fi
echo "... $mycc found"

echo "writing the platform file rod/platdef.c"
cat >build/platdef.c <<_CATEOF
#include "nimbase.h"
N_NIMCALL(char*, nimOS) { return "$myos"; }
N_NIMCALL(char*, nimCPU) { return "$myarch"; }

_CATEOF

echo "writing the configuration file config/nimrod.cfg"
# write configuration file:
cat >config/nimrod.cfg <<_CATEOF
%(configtempl)s
_CATEOF

cfiles="build/${myos}_${myarch}/"

# Compile the compiler:
echo "compiling: "
%(compile)s

# Link:
%(link)s

# Remove generated .o files:
%(cleanup)s

echo "Installation successful!"
"""



  TNimSlotsKind = enum nsLinear, nsBranch
  TNimSlots {.exportc.} = record
    len: int
    case kind: TNimSlotsKind
    of nsLinear:
      fields: ptr array[0..0x7fff, TNimSlot]
    of nsBranch:
      discriminant: TNimSlot
      branches: ptr array [0..0x7fff, ptr TNimSlots]

------------------------------------------------------------------------------

//
//
//           The Nimrod Compiler
//        (c) Copyright 2008 Andreas Rumpf
//
//    See the file "copying.txt", included in this
//    distribution, for details about the copyright.
//

// This module implements the renderer of the standard Nimrod representation.

unit rnimsyn;

{$include config.inc}

interface

uses
  nsystem, charsets, scanner, options, idents, strutils, ast, msgs, lists;

type
  TRenderFlag = (renderNone, renderNoBody, renderNoComments);
  TRenderFlags = set of TRenderFlag;

procedure renderModule(n: PNode; const filename: string;
                       renderFlags: TRenderFlags = {@set}[]);

function renderTree(n: PNode; renderFlags: TRenderFlags = {@set}[]): string;

implementation

// We render the source code in a two phases: The first
// determines how long the subtree will likely be, the second
// phase appends to a buffer that will be the output.

const
  IndentWidth = 2;
  longIndentWid = 4;
  MaxLineLen = 80;
  LineCommentColumn = 30;

type
  TSrcGen = record
    indent: int;
    lineLen: int;
    b: string;
    pendingNL: int; // negative if not active; else contains the
                    // indentation value
    comStack: array of PNode;  // comment stack
    flags: TRenderFlags;
  end;

procedure InitSrcGen(out g: TSrcGen; renderFlags: TRenderFlags);
begin
{@ignore}
  fillChar(g, sizeof(g), 0);
  g.comStack := nil;
{@emit
  g.comStack := [];
}
  g.indent := 0;
  g.lineLen := 0;
  g.b := '';
  g.flags := renderFlags;
  g.pendingNL := -1;
end;

{@ignore}
procedure add(var dest: string; const src: string);
begin
  dest := dest +{&} src;
end;
{@emit}

procedure addPendingNL(var g: TSrcGen);
begin
  if g.pendingNL >= 0 then begin
    add(g.b, charsets.NL);
    add(g.b, repeatChar(g.pendingNL));
    g.lineLen := g.pendingNL;
    g.pendingNL := -1;
  end
end;

procedure putNL(var g: TSrcGen; indent: int); overload;
begin
  if g.pendingNL >= 0 then
    addPendingNL(g)
  else
    add(g.b, charsets.NL);
  g.pendingNL := indent;
  g.lineLen := indent;
end;

procedure putNL(var g: TSrcGen); overload;
begin
  putNL(g, g.indent);
end;

procedure optNL(var g: TSrcGen; indent: int); overload;
begin
  g.pendingNL := indent;
  g.lineLen := indent; // BUGFIX
end;

procedure optNL(var g: TSrcGen); overload;
begin
  optNL(g, g.indent)
end;

procedure indentNL(var g: TSrcGen);
begin
  inc(g.indent, indentWidth);
  g.pendingNL := g.indent;
  g.lineLen := g.indent;
end;

procedure Dedent(var g: TSrcGen);
begin
  dec(g.indent, indentWidth);
  assert(g.indent >= 0);
  if g.pendingNL > indentWidth then begin
    Dec(g.pendingNL, indentWidth);
    Dec(g.lineLen, indentWidth)
  end
end;

procedure put(var g: TSrcGen; const s: string);
begin
  addPendingNL(g);
  add(g.b, s);
  inc(g.lineLen, length(s));
end;

procedure putChar(var g: TSrcGen; c: Char);
begin
  addPendingNL(g);
  addChar(g.b, c);
  inc(g.lineLen, 1);
end;

procedure putLong(var g: TSrcGen; const s: string;
                  lineLen: int);
// use this for tokens over multiple lines.
begin
  addPendingNL(g);
  add(g.b, s);
  g.lineLen := lineLen;
end;

// ----------------------- helpers --------------------------------------------

function toNimChar(c: Char): string;
begin
  case c of
    #0: result := '\0';
    #1..#31, #128..#255: result := '\x' + strutils.toHex(ord(c), 2);
    '''', '"', '\': result := '\' + c;
    else result := c + ''
  end;
end;

function makeNimString(const s: string): string;
var
  i: int;
begin
  result := '"' + '';
  for i := strStart to length(s)+strStart-1 do begin
    result := result +{&} toNimChar(s[i]);
  end;
  result := result + '"';
end;

procedure putComment(var g: TSrcGen; s: string);
var
  i, j, ind, comIndent: int;
  isCode: bool;
begin
  {@ignore} s := s + #0; {@emit}
  i := strStart;
  comIndent := 1;
  isCode := (length(s) >= 2) and (s[strStart+1] <> ' ');
  ind := g.lineLen;
  while true do begin
    case s[i] of
      #0: break;
      #13: begin
        inc(i);
        if s[i] = #10 then inc(i);
        optNL(g, ind);
      end;
      #10: begin
        inc(i);
        optNL(g, ind);
      end;
      '#': begin
        putChar(g, s[i]);
        inc(i);
        comIndent := 0;
        while s[i] = ' ' do begin
          putChar(g, s[i]);
          inc(i); inc(comIndent);
        end
      end;
      ' ', #9: begin
        putChar(g, s[i]);
        inc(i);
      end
      else begin
        // we may break the comment into a multi-line comment if the line
        // gets too long:

        // compute length of the following word:
        j := i;
        while s[j] > ' ' do inc(j);
        if not isCode and (g.lineLen + (j-i) > MaxLineLen) then begin
          optNL(g, ind);
          put(g, '#' +{&} repeatChar(comIndent));
        end;
        while s[i] > ' ' do begin
          putChar(g, s[i]);
          inc(i);
        end
      end
    end
  end;
  optNL(g);
end;

function maxLineLength(s: string): int;
var
  i, linelen: int;
begin
  {@ignore} s := s + #0; {@emit}
  result := 0;
  i := strStart;
  lineLen := 0;
  while true do begin
    case s[i] of
      #0: break;
      #13: begin
        inc(i);
        if s[i] = #10 then inc(i);
        result := max(result, lineLen);
        lineLen := 0;
      end;
      #10: begin
        inc(i);
        result := max(result, lineLen);
        lineLen := 0;
      end;
      else begin
        inc(lineLen); inc(i);
      end
    end
  end
end;

procedure putRawStr(var g: TSrcGen; const s: string);
var
  i, hi: int;
begin
  i := strStart;
  hi := length(s)+strStart-1;
  while i <= hi do begin
    case s[i] of
      #13: begin
        inc(i);
        if (i <= hi) and (s[i] = #10) then inc(i);
        optNL(g, 0);
      end;
      #10: begin
        inc(i);
        optNL(g, 0);
      end;
      else begin
        putChar(g, s[i]);
        inc(i)
      end
    end
  end
end;

function containsNL(const s: string): bool;
var
  i: int;
begin
  for i := strStart to length(s)+strStart-1 do
    case s[i] of
      #13, #10: begin result := true; exit end;
      else begin end
    end;
  result := false
end;

procedure pushCom(var g: TSrcGen; n: PNode);
var
  len: int;
begin
  len := length(g.comStack);
  setLength(g.comStack, len+1);
  g.comStack[len] := n;
end;

procedure popAllComs(var g: TSrcGen);
begin
  setLength(g.comStack, 0);
end;

procedure popCom(var g: TSrcGen);
begin
  setLength(g.comStack, length(g.comStack)-1);
end;

const
  Space = ' '+'';

procedure gcom(var g: TSrcGen; n: PNode);
var
  ml: int;
begin
  assert(n <> nil);
  if (n.comment <> snil) and not (renderNoComments in g.flags) then begin
    if (g.pendingNL < 0) and (length(g.b) > 0)
    and (g.b[length(g.b)] <> ' ') then
      put(g, Space);
    // Before long comments we cannot make sure that a newline is generated,
    // because this might be wrong. But it is no problem in practice.
    if (g.pendingNL < 0) and (length(g.b) > 0)
        and (g.lineLen < LineCommentColumn) then begin
      ml := maxLineLength(n.comment);
      if ml+LineCommentColumn <= maxLineLen then
        put(g, repeatChar(LineCommentColumn - g.lineLen));
    end;
    putComment(g, n.comment);
    //assert(g.comStack[high(g.comStack)] = n);
  end
end;

procedure gcoms(var g: TSrcGen);
var
  i: int;
begin
  for i := 0 to high(g.comStack) do gcom(g, g.comStack[i]);
  popAllComs(g);
end;

// ----------------------------------------------------------------------------

function lsub(n: PNode): int; forward;

function litAux(n: PNode; x: biggestInt; size: int): string;
begin
  case n.base of
    base10: result := toString(x);
    base2:  result := '0b' + toBin(x, size*8);
    base8:  result := '0o' + toOct(x, size*3);
    base16: result := '0x' + toHex(x, size*2);
    else begin
      assert(false);
      result := toString(x);
    end
  end
end;

function atom(n: PNode): string;
var
  f: float32;
begin
  case n.kind of
    nkEmpty:        result := '';
    nkIdent:        result := n.ident.s;
    nkSym:          result := n.sym.name.s;
    nkStrLit:       result := makeNimString(n.strVal);
    nkRStrLit:      result := 'r"' + n.strVal + '"';
    nkTripleStrLit: result := '"""' + n.strVal + '"""';
    nkCharLit:      result := '''' + toNimChar(n.strVal[strStart]) + '''';
    nkRCharLit:     result := 'r''' + n.strVal[strStart] + '''';
    nkIntLit:       result := litAux(n, n.intVal, 4);
    nkInt8Lit:      result := litAux(n, n.intVal, 1) + '''i8';
    nkInt16Lit:     result := litAux(n, n.intVal, 2) + '''i16';
    nkInt32Lit:     result := litAux(n, n.intVal, 4) + '''i32';
    nkInt64Lit:     result := litAux(n, n.intVal, 8) + '''i64';
    nkFloatLit:     begin
      if n.base = base10 then result := toStringF(n.floatVal)
      else result := litAux(n, PInt64(addr(n.floatVal))^, 8);
    end;
    nkFloat32Lit:   begin
      if n.base = base10 then
        result := toStringF(n.floatVal) + '''f32'
      else begin
        f := n.floatVal;
        result := litAux(n, PInt32(addr(f))^, 4) + '''f32'
      end;
    end;
    nkFloat64Lit:   begin
      if n.base = base10 then
        result := toStringF(n.floatVal) + '''f64'
      else
        result := litAux(n, PInt64(addr(n.floatVal))^, 8) + '''f64';
    end;
    nkNilLit: result := 'nil';
    nkType: begin
      if (n.typ <> nil) and (n.typ.sym <> nil) then result := n.typ.sym.name.s
      else result := '[type node]';
    end;
    else InternalError('rnimsyn.atom ' + nodeKindToStr[n.kind]);
  end
end;

// ---------------------------------------------------------------------------

function lcomma(n: PNode; start: int = 0; theEnd: int = -1): int;
var
  i: int;
begin
  assert(theEnd < 0);
  result := 0;
  for i := start to sonsLen(n)+theEnd do begin
    inc(result, lsub(n.sons[i]));
    inc(result, 2); // for ``, ``
  end;
  if result > 0 then dec(result, 2); // last does not get a comma!
end;

function lsons(n: PNode; start: int = 0; theEnd: int = -1): int;
var
  i: int;
begin
  assert(theEnd < 0);
  result := 0;
  for i := start to sonsLen(n)+theEnd do inc(result, lsub(n.sons[i]));
end;

function lsub(n: PNode): int;
// computes the length of a tree
var
  len: int;
begin
  if n = nil then begin result := 0; exit end;
  if n.comment <> snil then begin result := maxLineLen+1; exit end;
  len := sonsLen(n);
  case n.kind of
    nkTripleStrLit: begin
      if containsNL(n.strVal) then result := maxLineLen+1
      else result := length(atom(n));
    end;
    nkEmpty..nkRStrLit, nkCharLit..nkNilLit: result := length(atom(n));
    nkCall, nkBracketExpr, nkConv: result := lsub(n.sons[0])+lcomma(n, 1)+2;
    nkHiddenStdConv, nkHiddenSubConv, nkHiddenCallConv: begin
      result := lsub(n.sons[0]);
    end;
    nkCast: result := lsub(n.sons[0])+lsub(n.sons[1])+length('cast[]()');
    nkAddr: result := lsub(n.sons[0])+length('addr()');
    nkCommand: result := lsub(n.sons[0])+lcomma(n, 1)+1;
    nkExprEqExpr, nkDefaultTypeParam, nkAsgn:
      result := lsons(n)+3;
    nkPar, nkRecordConstr, nkConstRecordConstr,
    nkCurly, nkSetConstr, nkConstSetConstr,
    nkBracket, nkArrayConstr, nkConstArrayConstr: result := lcomma(n)+2;
    nkQualified, nkDotExpr: result := lsons(n)+1;
    nkLambda: result := lsons(n)+length('lambda__=_');
    nkConstDef, nkIdentDefs: begin
      result := lcomma(n, 0, -3);
      if n.sons[len-2] <> nil then
        result := result + lsub(n.sons[len-2]) + 2;
      if n.sons[len-1] <> nil then
        result := result + lsub(n.sons[len-1]) + 3;
    end;
    nkExprColonExpr:  result := lsons(n) + 2;
    nkInfix:          result := lsons(n) + 2;
    nkPrefix:         result := lsons(n) + 1;
    nkPostfix:        result := lsons(n);
    nkPragmaExpr:     result := lsub(n.sons[0])+lcomma(n, 1)+4;
    nkRange:          result := lsons(n) + 2;
    nkDerefExpr:      result := lsub(n.sons[0])+2;
    nkImportAs:       result := lsons(n) + length('_as_');
    nkAccQuoted:      result := lsub(n.sons[0]) + 2;
    nkHeaderQuoted:   result := lsub(n.sons[0]) + lsub(n.sons[1]) + 2;

    nkIfExpr:         result := lsub(n.sons[0].sons[0])+lsub(n.sons[0].sons[1])
                              + lsons(n, 1) + length('if_:_');
    nkElifExpr:       result := lsons(n) + length('elif_:_');
    nkElseExpr:       result := lsub(n.sons[0])+ length('else:_');

    // type descriptions
    nkTypeOfExpr:     result := lsub(n.sons[0])+length('type_');
    nkRefTy:          result := lsub(n.sons[0])+length('ref_');
    nkPtrTy:          result := lsub(n.sons[0])+length('ptr_');
    nkVarTy:          result := lsub(n.sons[0])+length('var_');
    nkTypeDef:        result := lsons(n)+3;
    nkOfInherit:      result := lsub(n.sons[0])+length('of_');
    nkProcTy:         result := lsons(n)+length('proc_');
    nkEnumTy:         result := lsub(n.sons[0])+lcomma(n,1)+length('enum_');
    nkEnumFieldDef:   result := lsons(n)+3;

    nkVarSection:     if len > 1 then result := maxLineLen+1
                      else result := lsons(n) + length('var_');
    nkReturnStmt:     result := lsub(n.sons[0])+length('return_');
    nkRaiseStmt:      result := lsub(n.sons[0])+length('raise_');
    nkYieldStmt:      result := lsub(n.sons[0])+length('yield_');
    nkDiscardStmt:    result := lsub(n.sons[0])+length('discard_');
    nkBreakStmt:      result := lsub(n.sons[0])+length('break_');
    nkContinueStmt:   result := lsub(n.sons[0])+length('continue_');
    nkPragma:         result := lcomma(n) + 4;
    nkCommentStmt:    result := length(n.comment);

    nkOfBranch:       result := lcomma(n, 0, -2) + lsub(n.sons[len-1])
                              + length('of_:_');
    nkElifBranch:     result := lsons(n)+length('elif_:_');
    nkElse:           result := lsub(n.sons[0]) + length('else:_');
    nkFinally:        result := lsub(n.sons[0]) + length('finally:_');
    nkGenericParams:  result := lcomma(n) + 2;
    nkFormalParams:   begin
      result := lcomma(n, 1) + 2;
      if n.sons[0] <> nil then result := result + lsub(n.sons[0]) + 2
    end;
    nkExceptBranch:   result := lcomma(n, 0, -2) + lsub(n.sons[len-1])
                              + length('except_:_');
    else result := maxLineLen+1
  end
end;

function fits(const g: TSrcGen; x: int): bool;
begin
  result := x + g.lineLen <= maxLineLen
end;

// ------------------------- render part --------------------------------------

type
  TSubFlag = (rfLongMode, rfNoIndent, rfInConstExpr);
  TSubFlags = set of TSubFlag;
  TContext = record
    spacing: int;
    flags: TSubFlags;
  end;

const
  emptyContext: TContext = (spacing: 0; flags: {@set}[]);

procedure initContext(out c: TContext);
begin
  c.spacing := 0;
  c.flags := {@set}[];
end;

procedure gsub(var g: TSrcGen; n: PNode; const c: TContext); overload; forward;

procedure gsub(var g: TSrcGen; n: PNode); overload;
var
  c: TContext;
begin
  initContext(c);
  gsub(g, n, c);
end;

function one(b: bool): int;
begin
  if b then result := 1 else result := 0
end;

function hasCom(n: PNode): bool;
var
  i: int;
begin
  result := false;
  if n = nil then exit;
  if n.comment <> snil then begin result := true; exit end;
  case n.kind of
    nkEmpty..nkNilLit: begin end;
    else begin
      for i := 0 to sonsLen(n)-1 do
        if hasCom(n.sons[i]) then begin
          result := true; exit
        end
    end
  end
end;

procedure gcommaAux(var g: TSrcGen; n: PNode; ind: int;
                    start: int = 0; theEnd: int = -1);
var
  i, sublen: int;
  c: bool;
begin
  for i := start to sonsLen(n)+theEnd do begin
    c := i < sonsLen(n)+theEnd;
    sublen := lsub(n.sons[i])+one(c);
    if not fits(g, sublen) and (ind+sublen < maxLineLen) then optNL(g, ind);
    gsub(g, n.sons[i]);
    if c then put(g, ', ');
    if hasCom(n.sons[i]) then begin
      gcoms(g);
      optNL(g, ind);
    end
  end
end;

procedure gcomma(var g: TSrcGen; n: PNode; const c: TContext;
                 start: int = 0; theEnd: int = -1); overload;
var
  ind: int;
begin
  if rfInConstExpr in c.flags then
    ind := g.indent + indentWidth
  else begin
    ind := g.lineLen;
    if ind > maxLineLen div 2 then ind := g.indent + longIndentWid
  end;
  gcommaAux(g, n, ind, start, theEnd);
end;

procedure gcomma(var g: TSrcGen; n: PNode;
                 start: int = 0; theEnd: int = -1); overload;
var
  ind: int;
begin
  ind := g.lineLen;
  if ind > maxLineLen div 2 then ind := g.indent + longIndentWid;
  gcommaAux(g, n, ind, start, theEnd);
end;

procedure gsons(var g: TSrcGen; n: PNode; const c: TContext;
                start: int = 0; theEnd: int = -1);
var
  i: int;
begin
  for i := start to sonsLen(n)+theEnd do begin
    gsub(g, n.sons[i], c);
  end
end;

procedure gsection(var g: TSrcGen; n: PNode; const c: TContext;
                   const kind: string);
var
  i: int;
begin
  if sonsLen(n) = 0 then exit; // empty var sections are possible
  put(g, kind);
  put(g, Space);
  gcoms(g);
  indentNL(g);
  for i := 0 to sonsLen(n)-1 do begin
    optNL(g);
    gsub(g, n.sons[i], c);
    gcoms(g);
  end;
  dedent(g);
end;


function longMode(n: PNode; start: int = 0; theEnd: int = -1): bool;
var
  i: int;
begin
  result := n.comment <> snil;
  if not result then begin
    // check further
    for i := start to sonsLen(n)+theEnd do begin
      if (lsub(n.sons[i]) > maxLineLen) then begin
        longMode := true; break end;
    end
  end
end;

procedure gstmts(var g: TSrcGen; n: PNode; const c: TContext);
var
  i: int;
begin
  if n = nil then exit;
  if (n.kind = nkStmtList) or (n.kind = nkStmtListExpr) then begin
    indentNL(g);
    for i := 0 to sonsLen(n)-1 do begin
      optNL(g);
      gsub(g, n.sons[i]);
      gcoms(g);
    end;
    dedent(g);
  end
  else begin
    if rfLongMode in c.flags then indentNL(g);
    gsub(g, n);
    gcoms(g);
    optNL(g);
    if rfLongMode in c.flags then dedent(g);
  end
end;

procedure gif(var g: TSrcGen; n: PNode);
var
  c: TContext;
  i, len: int;
begin
  gsub(g, n.sons[0].sons[0]);
  initContext(c);
  put(g, ': ');
  if longMode(n) or (lsub(n.sons[0].sons[1])+g.lineLen > maxLineLen) then
    include(c.flags, rfLongMode);
  gcoms(g); // a good place for comments
  gstmts(g, n.sons[0].sons[1], c);
  len := sonsLen(n);
  for i := 1 to len-1 do begin
    optNL(g);
    gsub(g, n.sons[i], c)
  end;
end;

procedure gwhile(var g: TSrcGen; n: PNode);
var
  c: TContext;
begin
  put(g, 'while ');
  gsub(g, n.sons[0]);
  put(g, ': ');
  initContext(c);
  if longMode(n) or (lsub(n.sons[1])+g.lineLen > maxLineLen) then
    include(c.flags, rfLongMode);
  gcoms(g); // a good place for comments
  gstmts(g, n.sons[1], c);
end;

procedure gtry(var g: TSrcGen; n: PNode);
var
  c: TContext;
begin
  put(g, 'try: ');
  initContext(c);
  if longMode(n) or (lsub(n.sons[0])+g.lineLen > maxLineLen) then
    include(c.flags, rfLongMode);
  gcoms(g); // a good place for comments
  gstmts(g, n.sons[0], c);
  gsons(g, n, c, 1);
end;

procedure gfor(var g: TSrcGen; n: PNode);
var
  c: TContext;
  len: int;
begin
  len := sonsLen(n);
  put(g, 'for ');
  initContext(c);
  if longMode(n)
      or (lsub(n.sons[len-1])
        + lsub(n.sons[len-2]) + 6 + g.lineLen > maxLineLen) then
    include(c.flags, rfLongMode);
  gcomma(g, n, c, 0, -3);
  put(g, ' in ');
  gsub(g, n.sons[len-2], c);
  put(g, ': ');
  gcoms(g);
  gstmts(g, n.sons[len-1], c);
end;

procedure gmacro(var g: TSrcGen; n: PNode);
var
  c: TContext;
begin
  initContext(c);
  gsub(g, n.sons[0]);
  put(g, ': ');
  if longMode(n) or (lsub(n.sons[1])+g.lineLen > maxLineLen) then
    include(c.flags, rfLongMode);
  gcoms(g);
  gsons(g, n, c, 1);
end;

procedure gcase(var g: TSrcGen; n: PNode);
var
  c: TContext;
  len, last: int;
begin
  initContext(c);
  len := sonsLen(n);
  if n.sons[len-1].kind = nkElse then last := -2
  else last := -1;
  if longMode(n, 0, last) then include(c.flags, rfLongMode);
  put(g, 'case ');
  gsub(g, n.sons[0]);
  gcoms(g);
  optNL(g);
  gsons(g, n, c, 1, last);
  if last = -2 then begin
    initContext(c);
    if longMode(n.sons[len-1]) then include(c.flags, rfLongMode);
    gsub(g, n.sons[len-1], c);
  end
end;

procedure gproc(var g: TSrcGen; n: PNode);
var
  c: TContext;
begin
  gsub(g, n.sons[0]);
  gsub(g, n.sons[1]);
  gsub(g, n.sons[2]);
  gsub(g, n.sons[3]);
  if not (renderNoBody in g.flags) then begin
    if n.sons[4] <> nil then begin
      put(g, ' = ');
      indentNL(g);
      gcoms(g);
      dedent(g);
      initContext(c);
      gstmts(g, n.sons[4], c);
      putNL(g);
    end
    else begin
      indentNL(g);
      gcoms(g);
      dedent(g);
    end
  end;
end;

procedure gblock(var g: TSrcGen; n: PNode);
var
  c: TContext;
begin
  initContext(c);
  put(g, 'block ');
  gsub(g, n.sons[0]);
  put(g, ': ');
  if longMode(n) or (lsub(n.sons[1])+g.lineLen > maxLineLen) then
    include(c.flags, rfLongMode);
  gcoms(g);
  gstmts(g, n.sons[1], c);
end;

procedure gasm(var g: TSrcGen; n: PNode);
begin
  put(g, 'asm ');
  gsub(g, n.sons[0]);
  gcoms(g);
  gsub(g, n.sons[1]);
end;

procedure gsub(var g: TSrcGen; n: PNode; const c: TContext);
var
  len, i: int;
  a: TContext;
begin
  if n = nil then exit;
  if n.comment <> snil then pushCom(g, n);
  len := sonsLen(n);
  case n.kind of
    // atoms:
    nkTripleStrLit: putRawStr(g, n.strVal);
    nkEmpty..nkRStrLit, nkCharLit..nkNilLit: put(g, atom(n));
    // complex expressions
    nkCall, nkConv, nkDotCall: begin
      if sonsLen(n) >= 1 then 
        gsub(g, n.sons[0]);
      put(g, '('+'');
      gcomma(g, n, 1);
      put(g, ')'+'');
    end;
    nkHiddenStdConv, nkHiddenSubConv, nkHiddenCallConv: begin
      gsub(g, n.sons[0]);
    end;
    nkCast: begin
      put(g, 'cast[');
      gsub(g, n.sons[0]);
      put(g, '](');
      gsub(g, n.sons[1]);
      put(g, ')'+'');
    end;
    nkAddr: begin
      put(g, 'addr(');
      gsub(g, n.sons[0]);
      put(g, ')'+'');
    end;
    nkBracketExpr: begin
      gsub(g, n.sons[0]);
      put(g, '['+'');
      gcomma(g, n, 1);
      put(g, ']'+'');
    end;
    nkPragmaExpr: begin
      gsub(g, n.sons[0]);
      put(g, '{.'+'');
      gcomma(g, n, 1);
      put(g, '.}'+'');
    end;
    nkCommand: begin
      gsub(g, n.sons[0]);
      put(g, space);
      gcomma(g, n, 1);
    end;
    nkExprEqExpr, nkDefaultTypeParam, nkAsgn: begin
      gsub(g, n.sons[0]);
      put(g, ' = ');
      gsub(g, n.sons[1]);
    end;
    nkPar, nkRecordConstr, nkConstRecordConstr: begin
      put(g, '('+'');
      gcomma(g, n, c);
      put(g, ')'+'');
    end;
    nkCurly, nkSetConstr, nkConstSetConstr: begin
      put(g, '{'+'');
      gcomma(g, n, c);
      put(g, '}'+'');
    end;
    nkBracket, nkArrayConstr, nkConstArrayConstr: begin
      put(g, '['+'');
      gcomma(g, n, c);
      put(g, ']'+'');
    end;
    nkQualified, nkDotExpr: begin
      gsub(g, n.sons[0]);
      put(g, '.'+'');
      gsub(g, n.sons[1]);
    end;
    nkLambda: begin
      assert(n.sons[genericParamsPos] = nil);
      put(g, 'lambda ');
      gsub(g, n.sons[paramsPos]);
      gsub(g, n.sons[pragmasPos]);
      put(g, ' = ');
      gsub(g, n.sons[codePos]);
    end;
    nkConstDef, nkIdentDefs: begin
      gcomma(g, n, 0, -3);
      if n.sons[len-2] <> nil then begin
        put(g, ': ');
        gsub(g, n.sons[len-2])
      end;
      if n.sons[len-1] <> nil then begin
        put(g, ' = ');
        gsub(g, n.sons[len-1], c)
      end;
    end;
    nkExprColonExpr: begin
      gsub(g, n.sons[0]);
      put(g, ': ');
      gsub(g, n.sons[1]);
    end;
    nkInfix: begin
      gsub(g, n.sons[1]);
      put(g, Space);
      gsub(g, n.sons[0]); // binary operator
      if not fits(g, lsub(n.sons[2])+ lsub(n.sons[0]) + 1) then
        optNL(g, g.indent+longIndentWid)
      else put(g, Space);
      gsub(g, n.sons[2]);
    end;
    nkPrefix: begin
      gsub(g, n.sons[0]);
      put(g, space);
      gsub(g, n.sons[1]);
    end;
    nkPostfix: begin
      gsub(g, n.sons[1]);
      gsub(g, n.sons[0]);
    end;
    nkRange: begin
      gsub(g, n.sons[0]);
      put(g, '..');
      gsub(g, n.sons[1]);
    end;
    nkDerefExpr: begin
      gsub(g, n.sons[0]);
      put(g, '^ '); // unfortunately this requires a space, because ^. would be
                    // only one operator
    end;
    nkImportAs: begin
      gsub(g, n.sons[0]);
      put(g, ' as ');
      gsub(g, n.sons[1]);
    end;
    nkAccQuoted: begin
      put(g, '`'+'');
      gsub(g, n.sons[0]);
      put(g, '`'+'');
    end;
    nkHeaderQuoted: begin
      put(g, '`'+'');
      gsub(g, n.sons[0]);
      gsub(g, n.sons[1]);
      put(g, '`'+'');
    end;
    nkIfExpr: begin
      put(g, 'if ');
      gsub(g, n.sons[0].sons[0]);
      put(g, ': ');
      gsub(g, n.sons[0].sons[1]);
      gsons(g, n, emptyContext, 1);
    end;
    nkElifExpr: begin
      put(g, 'elif ');
      gsub(g, n.sons[0]);
      put(g, ': ');
      gsub(g, n.sons[1]);
    end;
    nkElseExpr: begin
      put(g, 'else: ');
      gsub(g, n.sons[0]);
    end;

    nkTypeOfExpr: begin
      put(g, 'type ');
      gsub(g, n.sons[0]);
    end;
    nkRefTy: begin
      put(g, 'ref ');
      gsub(g, n.sons[0]);
    end;
    nkPtrTy: begin
      put(g, 'ptr ');
      gsub(g, n.sons[0]);
    end;
    nkVarTy: begin
      put(g, 'var ');
      gsub(g, n.sons[0]);
    end;
    nkTypeDef: begin
      gsub(g, n.sons[0]);
      gsub(g, n.sons[1]);
      put(g, ' = ');
      gsub(g, n.sons[2]);
    end;
    nkRecordTy: begin
      put(g, 'record ');
      gsub(g, n.sons[0]);
      gsub(g, n.sons[1]);
      gcoms(g);
      gsub(g, n.sons[2]);
    end;
    nkObjectTy: begin
      put(g, 'object ');
      gsub(g, n.sons[0]);
      gsub(g, n.sons[1]);
      gcoms(g);
      gsub(g, n.sons[2]);
    end;
    nkRecList: begin
      indentNL(g);
      for i := 0 to len-1 do begin
        optNL(g);
        gsub(g, n.sons[i], c);
        gcoms(g);
      end;
      dedent(g);
      putNL(g);
    end;
    nkOfInherit: begin
      put(g, 'of ');
      gsub(g, n.sons[0]);
    end;
    nkProcTy: begin
      put(g, 'proc ');
      gsub(g, n.sons[0]);
      gsub(g, n.sons[1]);
    end;
    nkEnumTy: begin
      put(g, 'enum ');
      gsub(g, n.sons[0]);
      gcoms(g);
      indentNL(g);
      gcommaAux(g, n, g.indent, 1);
      dedent(g);
    end;
    nkEnumFieldDef: begin
      gsub(g, n.sons[0]);
      put(g, ' = ');
      gsub(g, n.sons[1]);
    end;
    nkStmtList, nkStmtListExpr: gstmts(g, n, emptyContext);
    nkIfStmt: begin
      put(g, 'if ');
      gif(g, n);
    end;
    nkWhenStmt, nkRecWhen: begin
      put(g, 'when ');
      gif(g, n);
    end;
    nkWhileStmt: gwhile(g, n);
    nkCaseStmt, nkRecCase: gcase(g, n);
    nkMacroStmt: gmacro(g, n);
    nkTryStmt: gtry(g, n);
    nkForStmt: gfor(g, n);
    nkBlockStmt, nkBlockExpr: gblock(g, n);
    nkAsmStmt: gasm(g, n);
    nkProcDef: begin
      put(g, 'proc ');
      gproc(g, n);
    end;
    nkIteratorDef: begin
      put(g, 'iterator ');
      gproc(g, n);
    end;
    nkMacroDef: begin
      put(g, 'macro ');
      gproc(g, n);
    end;
    nkTemplateDef: begin
      put(g, 'template ');
      gproc(g, n);
    end;
    nkTypeSection: gsection(g, n, emptyContext, 'type');
    nkConstSection: begin
      initContext(a);
      include(a.flags, rfInConstExpr);
      gsection(g, n, a, 'const')
    end;
    nkVarSection: begin
      if len = 0 then exit;
      put(g, 'var ');
      if len > 1 then begin
        gcoms(g);
        indentNL(g);
        for i := 0 to len-1 do begin
          optNL(g);
          gsub(g, n.sons[i]);
          gcoms(g);
        end;
        dedent(g);
      end
      else
        gsub(g, n.sons[0]);
    end;
    nkReturnStmt: begin
      put(g, 'return ');
      gsub(g, n.sons[0]);
    end;
    nkRaiseStmt: begin
      put(g, 'raise ');
      gsub(g, n.sons[0]);
    end;
    nkYieldStmt: begin
      put(g, 'yield ');
      gsub(g, n.sons[0]);
    end;
    nkDiscardStmt: begin
      put(g, 'discard ');
      gsub(g, n.sons[0]);
    end;
    nkBreakStmt: begin
      put(g, 'break ');
      gsub(g, n.sons[0]);
    end;
    nkContinueStmt: begin
      put(g, 'continue ');
      gsub(g, n.sons[0]);
    end;
    nkPragma: begin
      put(g, '{.');
      gcomma(g, n, emptyContext);
      put(g, '.}');
    end;
    nkImportStmt: begin
      put(g, 'import ');
      gcoms(g);
      indentNL(g);
      gcommaAux(g, n, g.indent);
      dedent(g);
      putNL(g);
    end;
    nkFromStmt: begin
      put(g, 'from ');
      gsub(g, n.sons[0]);
      put(g, ' import ');
      gcomma(g, n, emptyContext, 1);
      putNL(g);
    end;
    nkIncludeStmt: begin
      put(g, 'include ');
      gcoms(g);
      indentNL(g);
      gcommaAux(g, n, g.indent);
      dedent(g);
      putNL(g);
    end;
    nkCommentStmt: begin
      gcoms(g);
      optNL(g);
    end;
    nkOfBranch: begin
      optNL(g);
      put(g, 'of ');
      gcomma(g, n, c, 0, -2);
      put(g, ': ');
      gcoms(g);
      gstmts(g, n.sons[len-1], c);
    end;
    nkElifBranch: begin
      optNL(g);
      put(g, 'elif ');
      gsub(g, n.sons[0]);
      put(g, ': ');
      gcoms(g);
      gstmts(g, n.sons[1], c)
    end;
    nkElse: begin
      optNL(g);
      put(g, 'else: ');
      gcoms(g);
      gstmts(g, n.sons[0], c)
    end;
    nkFinally: begin
      optNL(g);
      put(g, 'finally: ');
      gcoms(g);
      gstmts(g, n.sons[0], c)
    end;
    nkExceptBranch: begin
      optNL(g);
      put(g, 'except ');
      gcomma(g, n, 0, -2);
      put(g, ': ');
      gcoms(g);
      gstmts(g, n.sons[len-1], c)
    end;
    nkGenericParams: begin
      put(g, '['+'');
      gcomma(g, n);
      put(g, ']'+'');
    end;
    nkFormalParams: begin
      put(g, '('+'');
      gcomma(g, n, 1);
      put(g, ')'+'');
      if n.sons[0] <> nil then begin
        put(g, ': ');
        gsub(g, n.sons[0]);
      end;
      // XXX: gcomma(g, n, 1, -2);
    end;
    else begin
      InternalError(n.info, 'rnimsyn.gsub(' +{&} nodeKindToStr[n.kind] +{&} ')')
    end
  end
end;

function renderTree(n: PNode; renderFlags: TRenderFlags = {@set}[]): string;
var
  g: TSrcGen;
begin
  initSrcGen(g, renderFlags);
  gsub(g, n);
  result := g.b
end;

procedure renderModule(n: PNode; const filename: string;
                       renderFlags: TRenderFlags = {@set}[]);
var
  i: int;
  f: tTextFile;
  g: TSrcGen;
begin
  initSrcGen(g, renderFlags);
  for i := 0 to sonsLen(n)-1 do begin
    gsub(g, n.sons[i]);
    optNL(g);
    if n.sons[i] <> nil then
      case n.sons[i].kind of
        nkTypeSection, nkConstSection, nkVarSection, nkCommentStmt:
          putNL(g);
        else begin end
      end
  end;
  gcoms(g);
  if OpenFile(f, filename, fmWrite) then begin
    nimWrite(f, g.b);
    nimCloseFile(f);
  end;
end;

end.


------------------------------------------------------------------------------

const
  IntsPerTrunk = 8;
  InitIntSetSize = 8; // must be a power of two!
  BitsPerTrunk = IntsPerTrunk * sizeof(int) * 8;
  BitsPerInt = sizeof(int) * 8;

type
  PTrunk = ^TTrunk;
  TTrunk = record
    next: PTrunk; // all nodes are connected with this pointer
    key: int;    // start address at bit 0
    bits: array [0..IntsPerTrunk-1] of int; // a bit vector
  end;
  TTrunkSeq = array of PTrunk;
  TIntSet = record
    counter, max: int;
    head: PTrunk;
    data: TTrunkSeq;
  end;

function IntSetContains(const s: TIntSet; key: int): bool;
procedure IntSetIncl(var s: TIntSet; key: int);
procedure IntSetInit(var s: TIntSet);

function IntSetContainsOrIncl(var s: TIntSet; key: int): bool;

// ---------------- efficient integer sets ----------------------------------
// Same algorithm as the one the GC uses

procedure IntSetInit(var s: TIntSet);
begin
{@ignore}
  fillChar(s, sizeof(s), 0);
{@emit}
  setLength(s.data, InitIntSetSize);
  s.max := InitIntSetSize-1;
  s.counter := 0;
  s.head := nil
end;

function IntSetGet(const t: TIntSet; key: int): PTrunk;
var
  h: int;
begin
  h := key and t.max;
  while t.data[h] <> nil do begin
    if t.data[h].key = key then begin
      result := t.data[h]; exit
    end;
    h := nextTry(h, t.max)
  end;
  result := nil
end;

procedure IntSetRawInsert(const t: TIntSet; data: TTrunkSeq;
                          desc: PTrunk);
var
  h: int;
begin
  h := desc.key and t.max;
  while data[h] <> nil do begin
    assert(data[h] <> desc);
    h := nextTry(h, t.max)
  end;
  assert(data[h] = nil);
  data[h] := desc
end;

procedure IntSetEnlarge(var t: TIntSet);
var
  n: TTrunkSeq;
  i, oldMax: int;
begin
  oldMax := t.max;
  t.max := ((t.max+1)*2)-1;
  {@emit n := []}
  setLength(n, t.max + 1);
  for i := 0 to oldmax do
    if t.data[i] <> nil then
      IntSetRawInsert(t, n, t.data[i]);
  t.data := n
end;

function IntSetPut(var t: TIntSet; key: int): PTrunk;
var
  h: int;
begin
  h := key and t.max;
  while t.data[h] <> nil do begin
    if t.data[h].key = key then begin
      result := t.data[h]; exit
    end;
    h := nextTry(h, t.max)
  end;

  if (t.max+1) * 2 < t.counter * 3 then IntSetEnlarge(t);
  inc(t.counter);
  h := key and t.max;
  while t.data[h] <> nil do h := nextTry(h, t.max);
  assert(t.data[h] = nil);
  new(result);
{@ignore}
  fillChar(result^, sizeof(result^), 0);
{@emit}
  result.next := t.head;
  result.key := key;
  t.head := result;
  t.data[h] := result;
end;

// ---------- slightly higher level procs ----------------------------------

function IntSetContains(const s: TIntSet; key: int): bool;
var
  u: int;
  t: PTrunk;
begin
  u := key;
  t := IntSetGet(s, divu(u, BitsPerTrunk));
  if t <> nil then begin
    u := modu(u, BitsPerTrunk);
    result := (t.bits[divu(u, BitsPerInt)] 
      and (1 shl biggestUInt(modu(u, BitsPerInt)))) <> 0
  end
  else
    result := false
end;

procedure IntSetIncl(var s: TIntSet; key: int);
var
  u: int;
  t: PTrunk;
begin
  u := key;
  t := IntSetPut(s, divu(u, BitsPerTrunk));
  u := modu(u, BitsPerTrunk);
  t.bits[divu(u, BitsPerInt)] := t.bits[divu(u, BitsPerInt)]
                            or (1 shl biggestUInt(modu(u, BitsPerInt)));
end;

function IntSetContainsOrIncl(var s: TIntSet; key: int): bool;
var
  u: int;
  t: PTrunk;
begin
  u := key;
  t := IntSetGet(s, divu(u, BitsPerTrunk));
  if t <> nil then begin
    u := modu(u, BitsPerTrunk);
    result := (t.bits[divu(u, BitsPerInt)] 
          and (1 shl biggestUInt(modu(u, BitsPerInt)))) <> 0;
    if not result then
      t.bits[divu(u, BitsPerInt)] := t.bits[divu(u, BitsPerInt)]
                                or (1 shl biggestUint(modu(u, BitsPerInt)));
  end
  else begin
    IntSetIncl(s, key);
    result := false
  end
end;
