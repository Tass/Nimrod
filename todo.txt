version 0.9.0
=============

- closure: implement closure support for procs capturing nested
  module vars
- implicit deref for parameter matching

- ``borrow`` needs to take type classes into account
- optimize genericAssign in the code generator
- fix remaining closure bugs:
  - fix evals.nim with closures
  - implement "closure tuple consists of a single 'ref'" optimization


Bugs
----

- bug: aporia.nim(968, 5) Error: ambiguous identifier: 'DELETE' -- 
  use a qualifier
- bug: pragma statements in combination with symbol files are evaluated twice
  but this can lead to compilation errors
- bug: the parser is not strict enough with newlines: 'echo "a" echo "b"' 
  compiles
- bug: blocks can "export" an identifier but the CCG generates {} for them ...


version 0.9.XX
==============

- JS gen:
  - fix exception handling

- document 'do' notation
- rethink the syntax: distinction between expr and stmt is unfortunate; 
  indentation handling is quite complex too; problem with exception handling
  is that often the scope of ``try`` is wrong and apart from that ``try`` is
  a full blown statement; a ``try`` expression might be a good idea to make
  error handling more light-weight
- ``=`` should be overloadable; requires specialization for ``=``
- ``hoist`` pragma for loop hoisting
- document destructors; don't work yet when used as expression
- make use of ``tyIter`` to fix the implicit items/pairs issue
- make templates hygienic by default: try to gensym() everything in the 'block'
  of a template; find a better solution for gensym instead of `*ident`
- introduce 'callsite' magic and make macros and templates the same
- better support for macros that rewrite procs
- macros need access to types and symbols
- document nimdoc properly finally
- make 'clamp' a magic for the range stuff
- implement a warning message for shadowed 'result' variable
- implement the high level optimizer
- we need to support iteration of 2 different data structures in parallel
- implement proper coroutines
- proc specialization in the code gen for write barrier specialization
- tlastmod returns wrong results on BSD (Linux, MacOS X: works)
- nested tuple unpacking; tuple unpacking in non-var-context
- 'nimrod def': does not always work?
- test branch coverage
- make pegs support a compile-time option and make c2nim use regexes instead
  per default?
- 'const' objects including case objects
- 'export' feature
- think about ``{:}.toTable[int, string]()``
- mocking support with ``tyProxy`` that does:
  o.p(x) --> p(o, x) -->  myMacro(p, o, x)
  
  This is really the opposite of ``tyExpr``:
  * For parameter ``tyExpr`` any argument matches.
  * Argument ``tyProxy`` matches any parameter.
  
- nice idea:

  p(a, b): 
    echo a
    echo b
  
  is the same as:
  
  p(a, b, proc() =
    echo a
    echo b)

Library
-------

- suffix trees
- locale support; i18n module
- bignums


Low priority
------------

- make 'raiseHook' take a closure and provide push and pop for this
  --> Lisp-style condition system
- change how comments are part of the AST
- fix & document ``byCopy`` pragma
- ``with proc `+`(x, y: T): T`` for generic code
- new feature: ``distinct T with operations``
- implement the "easy" constructors idea
- code generated for type information is wasteful
- resizing of strings/sequences could take into account the memory that
  is allocated
- timeout for locks
- compilation cache:
  - adapt thread var emulation to care about the new merge operation
  - check for interface changes; if only the implementation changes, no
    need to recompile clients; er ... what about templates, macros or anything
    that has inlining semantics?
- codegen should use "NIM_CAST" macro and respect aliasing rules for GCC
- GC: precise stack marking;
  escape analysis for string/seq seems to be easy to do too;
  even further write barrier specialization
- GC: marker procs Boehm GC
- implement marker procs for assignment and message passing
- warning for implicit openArray -> varargs conversion
- implement explicit varargs; **but** ``len(varargs)`` problem remains! 
  --> solve by implicit conversion from varargs to openarray
- optimize method dispatchers
- activate more thread tests
- implement ``--script:sh|bat`` command line option; think about script 
  generation
- implement closures that support nesting of *procs* > 1


Further optimization ideas
==========================

- To optimize further copies away, you want to gather the additional
  information inlining would provide, but don't inline for code size reasons.


Version 2 and beyond
====================

- shared memory heap: ``shared ref`` etc. The only hard part in the GC is to
  "stop the world". However, it may be worthwhile to generate explicit 
  (or implicit) syncGC() calls in loops. Automatic loop injection seems
  troublesome, but maybe we can come up with a simple heuristic. (All procs
  that `new` shared memory are syncGC() candidates...)

- implement/generalize the effect system; checked exceptions
- const ptr/ref

- language change: inheritance should only work with reference types, so that
  the ``type`` field is not needed for objects! --> zero overhead aggregation
  BETTER: ``of`` and safe object conversions only work with ref objects. Same
  for multi methods.
  
- explicit nil types?
  * nil seq[int]
  * nil string
  * nil ref int
  * nil ptr THallo
  * nil proc 

- better for backwards compatibility: default nilable, but ``not nil``
  notation:
  
  type
    PWindow = ref TWindow not nil
    
  The problem with ``nil`` is that the language currently relies on it for
  implicit initialization. Initialization is different from assignment. The
  issues can "easily" dealt with by ensuring:
  
    var x = myProc() # checks myProc() initializes every pointer explicitely

- guards for the 'case' statement; generalized case statement;
  a guard looks like: 
  
    case x
    of nkStmtList if x.value == 0: 
  
  a generalized case statement looks like:
    
    case x with `=~`

- implement ``partial`` pragma for partial evaluation
