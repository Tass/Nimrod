version 0.9.2
=============
  
- test&finish first class iterators:
  * tyIterator: implement nkIteratorTy, nkSharedTy
  * allow return in first class iterators
  * nested iterators
  * arglist as a type?

- fix closure bug finally
- overloading based on ASTs: 'constraint' should not be in PType but for the
  parameter *symbol*

  - implement ``partial`` pragma for partial evaluation: easily done with AST
    overloading
  - ``hoist`` pragma for loop hoisting: can be easily done with 
    AST overloading + global

- improve the compiler as a service
- ``=`` should be overloadable; requires specialization for ``=``
- implement constructors and non-nil types
- make 'bind' default for templates and introduce 'mixin'; 
  special rule for ``[]=``
- implicit deref for parameter matching; overloading based on 'var T'
- optimize genericAssign in the code generator


Bugs
----

- sneaking with qualifiedLookup() is really broken!
- bug: aporia.nim(968, 5) Error: ambiguous identifier: 'DELETE' -- 
  use a qualifier
- bug: the parser is not strict enough with newlines: 'echo "a" echo "b"' 
  compiles
- bug: blocks can "export" an identifier but the CCG generates {} for them ...
- bug: what if we pass an iterator to a proc var? iterators use tyProc too ...


version 0.9.XX
==============

- make:
  p(a, b): 
    echo a
    echo b
  
  the same as:
  
  p(a, b, proc() =
    echo a
    echo b)

- implement read/write tracking in the effect system
- implement the "snoopResult" pragma; no, make a strutils with string append
  semantics instead ...
- implement "closure tuple consists of a single 'ref'" optimization
- JS gen:
  - fix exception handling
- object branch transitions can't work with the current 'reset'; add a 'reset'
  with an additional parameter --> re-evaluate this issue after constructors
  have been added
- fix remaining closure bugs:
  - test evals.nim with closures
  - what about macros with closures?

- allow implicit forward declarations of procs via a pragma (so that the
  wrappers can deactivate it)
- rethink the syntax: distinction between expr and stmt is unfortunate; 
  indentation handling is quite complex too; problem with exception handling
  is that often the scope of ``try`` is wrong and apart from that ``try`` is
  a full blown statement; a ``try`` expression might be a good idea to make
  error handling more light-weight
- fix destructors; don't work yet when used as expression
- make use of ``tyIter`` to fix the implicit items/pairs issue
- better support for macros that rewrite procs
- macros need access to types and symbols (partially implemented)
- document nimdoc properly finally
- make 'clamp' a magic for the range stuff
- we need to support iteration of 2 different data structures in parallel
- proc specialization in the code gen for write barrier specialization
- tlastmod returns wrong results on BSD (Linux, MacOS X: works)
- nested tuple unpacking; tuple unpacking in non-var-context
- make pegs support a compile-time option and make c2nim use regexes instead
  per default?
- 'const' objects including case objects
- 'export' feature
- from buggymodule import * except optBroken, optBroken2
- think about ``{:}.toTable[int, string]()``
- mocking support with ``tyProxy`` that does:
  o.p(x) --> p(o, x) -->  myMacro(p, o, x)
  
  This is really the opposite of ``tyExpr``:
  * For parameter ``tyExpr`` any argument matches.
  * Argument ``tyProxy`` matches any parameter.
  

Library
-------

- suffix trees
- locale support; i18n module
- bignums


Low priority
------------

- change how comments are part of the AST
- ``with proc `+`(x, y: T): T`` for generic code
- new feature: ``distinct T with operations``
- implement the "easy" constructors idea
- resizing of strings/sequences could take into account the memory that
  is allocated
- timeout for locks
- compilation cache:
  - adapt thread var emulation to care about the new merge operation
  - check for interface changes; if only the implementation changes, no
    need to recompile clients; er ... what about templates, macros or anything
    that has inlining semantics?
- codegen should use "NIM_CAST" macro and respect aliasing rules for GCC
- GC: precise stack marking;
  escape analysis for string/seq seems to be easy to do too;
  even further write barrier specialization
- GC: marker procs Boehm GC
- implement marker procs for message passing
- optimize method dispatchers
- activate more thread tests
- implement ``--script:sh|bat`` command line option; think about script 
  generation
- implement closures that support nesting of *procs* > 1


Further optimization ideas
==========================

- To optimize further copies away, you want to gather the additional
  information inlining would provide, but don't inline for code size reasons.


Version 2 and beyond
====================

- shared memory heap: ``shared ref`` etc. The only hard part in the GC is to
  "stop the world". However, it may be worthwhile to generate explicit 
  (or implicit) syncGC() calls in loops. Automatic loop injection seems
  troublesome, but maybe we can come up with a simple heuristic. (All procs
  that `new` shared memory are syncGC() candidates... But then 'new' itself
  calls syncGC() so that's pointless.)

- const ptr/ref  --> pointless because of aliasing; 
  much better: 'writes: []' effect

- language change: inheritance should only work with reference types, so that
  the ``type`` field is not needed for objects! --> zero overhead aggregation
  BETTER: ``of`` and safe object conversions only work with ref objects. Same
  for multi methods.
  
- explicit nil types?
  * nil seq[int]
  * nil string
  * nil ref int
  * nil ptr THallo
  * nil proc 

- better for backwards compatibility: default nilable, but ``not nil``
  notation:
  
  type
    PWindow = ref TWindow not nil
    
  The problem with ``nil`` is that the language currently relies on it for
  implicit initialization. Initialization is different from assignment. The
  issues can "easily" dealt with by ensuring:
  
    var x = myProc() # checks myProc() initializes every pointer explicitely

- guards for the 'case' statement; generalized case statement;
  a guard looks like: 
  
    case x
    of nkStmtList if x.value == 0: 
  
  a generalized case statement looks like:
    
    case x with `=~`
