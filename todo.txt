version 0.9.0
=============

Debug GC session:
- test sequence of closures; especially that the GC does not leak for those!

New pragmas:
- ``hoist`` pragma for loop hoisting
- test & document ``byCopy`` pragma

- ``borrow`` needs to take type classes into account
- make templates hygienic by default: try to gensym() everything in the 'block'
  of a template; find a better solution for gensym instead of `*ident`
- ``=`` should be overloadable; requires specialization for ``=``
- optimize genericAssign in the code generator
- fix remaining closure bugs:
  - make toplevel but in a scope vars local; make procs there inner procs
  - fix evals.nim with closures
  - proc types shall have closure calling convention per default
  - implement "closure tuple consists of a single 'ref'" optimization

- document 'do' notation
- unsigned ints and bignums; requires abstract integer literal type: 
  use tyInt+node for that
- rethink the syntax: distinction between expr and stmt is unfortunate; 
  indentation handling is quite complex too; problem with exception handling
  is that often the scope of ``try`` is wrong and apart from that ``try`` is
  a full blown statement; a ``try`` expression might be a good idea to make
  error handling more light-weight
  people also want ``inc a; inc b``


Bugs
----

- bug: pragma statements in combination with symbol files are evaluated twice
  but this can lead to compilation errors


version 0.9.XX
==============

- document nimdoc properly finally
- implement a warning message for shadowed 'result' variable
- implement the high level optimizer
- change overloading resolution
- we need to support iteration of 2 different data structures in parallel
- implement proper coroutines
- implicit ref/ptr->var conversion; the compiler may store an object
  implicitly on the heap for write barrier efficiency; better: 
  proc specialization in the code gen
- EcmaScript needs a new and better code gen: simply adapt the C code gen to it
- dead code elim for JS backend; 'of' operator for JS backend
- tlastmod returns wrong results on BSD (Linux, MacOS X: works)
- nested tuple unpacking; tuple unpacking in non-var-context
- 'nimrod def': does not always work?
- test branch coverage
- make pegs support a compile-time option and make c2nim use regexes instead
  per default?
- 'const' objects including case objects
- 'export' feature
- think about ``{:}.toTable[int, string]()``
- mocking support with ``tyProxy`` that does:
  o.p(x) --> p(o, x) -->  myMacro(p, o, x)
  
  This is really the opposite of ``tyExpr``:
  * For parameter ``tyExpr`` any argument matches.
  * Argument ``tyProxy`` matches any parameter.
  
- nice idea:

  p(a, b): 
    echo a
    echo b
  
  is the same as:
  
  p(a, b, proc() =
    echo a
    echo b)

Library
-------

- suffix trees
- locale support; i18n module
- bignums

- pdcurses bindings

- for system:
  proc `@` [T](a: openArray[T]): seq[T] = 
    newSeq(result, a.len)
    for i in 0..a.len-1: result[i] = a[i]
    
  --> ensure @[] calls the array version!


Low priority
------------

- change how comments are part of the AST
- ``with proc `+`(x, y: T): T`` for generic code
- new feature: ``distinct T with operations``
- implement the "easy" constructors idea; document destructors
- code generated for type information is wasteful
- resizing of strings/sequences could take into account the memory that
  is allocated
- timeout for locks
- compilation cache:
  - adapt thread var emulation to care about the new merge operation
  - check for interface changes; if only the implemenation changes, no
    need to recompile clients; er ... what about templates, macros or anything
    that has inlining semantics?
- codegen should use "NIM_CAST" macro and respect aliasing rules for GCC
- GC: precise stack marking;
  escape analysis for string/seq seems to be easy to do too;
  even further write barrier specialization
- GC: marker procs Boehm GC
- implement marker procs for assignment and message passing
- warning for implicit openArray -> varargs conversion
- implement explicit varargs; **but** ``len(varargs)`` problem remains! 
  --> solve by implicit conversion from varargs to openarray
- optimize method dispatchers
- activate more thread tests
- implement ``--script:sh|bat`` command line option; think about script 
  generation
- implement closures that support nesting of *procs* > 1


Further optimization ideas
==========================

- To optimize further copies away, you want to gather the additional
  information inlining would provide, but don't inline for code size reasons.


Version 2 and beyond
====================


- shared memory heap: ``shared ref`` etc. The only hard part in the GC is to
  "stop the world". However, it may be worthwhile to generate explicit 
  (or implicit) syncGC() calls in loops. Automatic loop injection seems
  troublesome, but maybe we can come up with a simple heuristic. (All procs
  that `new` shared memory are syncGC() candidates...)

- implement/generalize the effect system; checked exceptions
- const ptr/ref

- language change: inheritance should only work with reference types, so that
  the ``type`` field is not needed for objects! --> zero overhead aggregation
  BETTER: ``of`` and safe object conversions only work with ref objects. Same
  for multi methods.
  
- explicit nil types?
  * nil seq[int]
  * nil string
  * nil ref int
  * nil ptr THallo
  * nil proc 

- better for backwards compatibility: default nilable, but ``not nil``
  notation:
  
  type
    PWindow = ref TWindow not nil
    
  The problem with ``nil`` is that the language currently relies on it for
  implicit initialization. Initialization is different from assignment. The
  issues can "easily" dealt with by ensuring:
  
    var x = myProc() # checks myProc() initializes every pointer explicitely

- guards for the 'case' statement; generalized case statement;
  a guard looks like: 
  
    case x
    of nkStmtList if x.value == 0: 
  
  a generalized case statement looks like:
    
    case x with `=~`

- implement ``partial`` pragma for partial evaluation
