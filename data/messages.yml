# This file contains all the messages of the Nimrod compiler
# (c) 2008 Andreas Rumpf

[
# fatal errors:
{'errUnknown': 'unknown error'},
{'errIllFormedAstX': 'illformed AST: $1'},
{'errCannotOpenFile': "cannot open '$1'"},
{'errInternal': 'internal error: $1'},

# other errors:
{'errGenerated': '$1'},
{'errXCompilerDoesNotSupportCpp': "'$1' compiler does not support C++"},

# errors:
{'errStringLiteralExpected': 'string literal expected'},
{'errIntLiteralExpected': 'integer literal expected'},
{'errInvalidCharacterConstant': 'invalid character constant'},
{'errClosingTripleQuoteExpected':
  'closing """ expected, but end of file reached'},
{'errClosingQuoteExpected': 'closing " expected'},
{'errTabulatorsAreNotAllowed': 'tabulators are not allowed'},
{'errInvalidToken': 'invalid token: $1'},
{'errLineTooLong': 'line too long'},
{'errInvalidNumber': '$1 is not a valid number'},
{'errNumberOutOfRange': 'number $1 out of valid range'},
{'errNnotAllowedInCharacter': '\\n not allowed in character literal'},
{'errClosingBracketExpected': "closing ']' expected, but end of file reached"},
{'errMissingFinalQuote': "missing final '"},
{'errIdentifierExpected': "identifier expected, but found '$1'"},
{'errOperatorExpected': "operator expected, but found '$1'"},
{'errTokenExpected': "'$1' expected"},
{'errStringAfterIncludeExpected': "string after 'include' expected"},
{'errRecursiveInclude': "recursive include file: '$1'"},
{'errOnOrOffExpected': "'on' or 'off' expected"},
{'errNoneSpeedOrSizeExpected': "'none', 'speed' or 'size' expected"},
{'errInvalidPragma': 'invalid pragma'},
{'errUnknownPragma': "unknown pragma: '$1'"},
{'errPragmaXHereNotAllowed': "pragma '$1' here not allowed"},
{'errUnknownDirective': "unknown directive: '$1'"},
{'errInvalidDirective': 'invalid directive'},
{'errAtPopWithoutPush': "'pop' without a 'push' pragma"},
{'errEmptyAsm': 'empty asm statement makes no sense'},
{'errAsgnInvalidInExpr': "'=' invalid in an expression; probably '==' meant"},
{'errInvalidIndentation': 'invalid indentation'},
{'errExceptionExpected': 'exception expected'},
{'errExceptionAlreadyHandled': 'exception already handled'},
{'errReturnNotAllowedHere': "'return' only allowed in routine"},
{'errYieldNotAllowedHere': "'yield' only allowed in iterator"},
{'errInvalidNumberOfYieldExpr': "invalid number of 'yield' expresions"},
{'errReturnInvalidInIterator': "'return' not allowed in iterator"},
{'errCannotReturnExpr': 'current routine cannot return an expression'},
{'errAttemptToRedefine': "attempt to redefine '$1'"},
{'errStmtInvalidAfterReturn':
  "statement not allowed after 'return', 'break' or 'raise'"},
{'errStmtExpected': 'statement expected'},
{'errYieldOnlyInInterators': "'yield' statement is only allowed in iterators"},
{'errInvalidLabel': "'$1' is no label"},
{'errInvalidCmdLineOption': "invalid command line option: '$1'"},
{'errCmdLineArgExpected': "argument for command line option expected: '$1'"},
{'errInvalidVarSubstitution': "invalid variable substitution in '$1'"},
{'errUnknownVar': "unknown variable: '$1'"},
{'errUnknownCcompiler': "unknown C compiler: '$1'"},
{'errOnOrOffExpectedButXFound': "'on' or 'off' expected, but '$1' found"},
{'errNoneBoehmRefcExpectedButXFound':
  "'none', 'boehm' or 'refc' expected, but '$1' found"},
{'errNoneSpeedOrSizeExpectedButXFound':
  "'none', 'speed' or 'size' expected, but '$1' found"},
{'errGuiConsoleOrLibExpectedButXFound':
  "'gui', 'console' or 'lib' expected, but '$1' found"},
{'errUnknownOS': "unknown OS: '$1'"},
{'errUnknownCPU': "unknown CPU: '$1'"},
{'errGenOutExpectedButXFound':
  "'c', 'c++' or 'yaml' expected, but '$1' found"},
{'errArgsNeedRunOption':
  "arguments can only be given if the '--run' option is selected"},
{'errInvalidMultipleAsgn': 'multiple assignment is not allowed'},
{'errColonOrEqualsExpected': "':' or '=' expected, but found '$1'"},
{'errExprExpected': "expression expected, but found '$1'"},
{'errUndeclaredIdentifier': "undeclared identifier: '$1'"},
{'errUseQualifier': "ambigious identifier: '$1' -- use a qualifier"},
{'errTwiceForwarded': "'$1' is forwarded twice"},
{'errTypeExpected': 'type expected'},
{'errSystemNeeds': "system module needs '$1'"},
{'errExecutionOfProgramFailed': 'execution of an external program failed'},
{'errNotOverloadable': "overloaded '$1' leads to ambigious calls"},
{'errInvalidArgForX': "invalid argument for '$1'"},
{'errStmtHasNoEffect': 'statement has no effect'},
{'errXExpectsTypeOrValue': "'$1' expects a type or value"},
{'errXExpectsArrayType': "'$1' expects an array type"},
{'errIteratorCannotBeInstantiated':
  "'$1' cannot be instantiated because its body has not been compiled yet"},
{'errExprWithNoTypeCannotBeConverted':
  'expression with no type cannot be converted'},
{'errExprWithNoTypeCannotBeCasted': 'expression with no type cannot be casted'},
{'errConstantDivisionByZero': 'constant division by zero'},
{'errOrdinalTypeExpected': 'ordinal type expected'},
{'errOrdinalOrFloatTypeExpected': 'ordinal or float type expected'},
{'errOverOrUnderflow': 'over- or underflow'},
{'errCannotEvalXBecauseIncompletelyDefined':
  "cannot evalutate '$1' because type is not defined completely"},
{'errChrExpectsRange0_255': "'chr' expects an int in the range 0..255"},
{'errStaticAssertFailed': "'staticAssert' failed: condition is false"},
{'errStaticAssertCannotBeEval':
  "argument to 'staticAssert' cannot be evaluated at compile time"},
{'errDotRequiresRecordOrObjectType': "'.' requires a record or object type"},
{'errUndeclaredFieldX': "undeclared field: '$1'"},
{'errIndexNoIntType': 'index has to be an integer type'},
{'errIndexOutOfBounds': 'index out of bounds'},
{'errIndexTypesDoNotMatch': 'index types do not match'},
{'errBracketsInvalidForType': "'[]' operator invalid for this type"},
{'errValueOutOfSetBounds': 'value out of set bounds'},
{'errFieldInitTwice': "field initialized twice: '$1'"},
{'errFieldNotInit': "field '$1' not initialized"},
{'errExprCannotBeCalled': 'expression cannot be called'},
{'errExprHasNoType': 'expression has no type'},
{'errExprXHasNoType': "expression '$1' has no type"},
{'errCastNotInSafeMode': "'cast' not allowed in safe mode"},
{'errExprCannotBeCastedToX': 'expression cannot be casted to $1'},
{'errUndefinedPrefixOpr': 'undefined prefix operator: $1'},
{'errCommaOrParRiExpected': "',' or ')' expected"},
{'errCurlyLeOrParLeExpected': "'{' or '(' expected"},
{'errSectionExpected': "section ('type', 'proc', etc.) expected"},
{'errImplemenationExpected': "'implementation' or end of file expected"},
{'errRangeExpected': 'range expected'},
{'errInvalidTypeDescription': 'invalid type description'},
{'errAttemptToRedefineX': "attempt to redefine '$1'"},
{'errMagicOnlyInSystem': "'magic' only allowed in system module"},
{'errUnknownOperatorX': "unkown operator: '$1'"},
{'errPowerOfTwoExpected': 'power of two expected'},
{'errStringMayNotBeEmpty': 'string literal may not be empty'},
{'errCallConvExpected': 'calling convention expected'},
{'errProcOnlyOneCallConv': 'a proc can only have one calling convention'},
{'errSymbolMustBeImported': "symbol must be imported if 'lib' pragma is used"},
{'errExprMustBeBool': "expression must be of type 'bool'"},
{'errConstExprExpected': 'constant expression expected'},
{'errDuplicateCaseLabel': 'duplicate case label'},
{'errRangeIsEmpty': 'range is empty'},
{'errSelectorMustBeOfCertainTypes':
  'selector must be of an ordinal type, real or string'},
{'errSelectorMustBeOrdinal':
  'selector must be of an ordinal type'},
{'errOrdXMustNotBeNegative': 'ord($1) must not be negative'},
{'errLenXinvalid': 'len($1) must be less than 32768'},
{'errWrongNumberOfVariables': 'wrong number of variables'},
{'errExprCannotBeRaised': 'only objects can be raised'},
{'errBreakOnlyInLoop': "'break' only allowed in loop construct"},
{'errTypeXhasUnknownSize': "type '$1' has unknown size"},
{'errConstNeedsConstExpr':
  'a constant can only be initialized with a constant expression'},
{'errConstNeedsValue': 'a constant needs a value'},
{'errResultCannotBeOpenArray': 'the result type cannot be on open array'},
{'errSizeTooBig': "computing the type's size produced an overflow"},
{'errSetTooBig': 'set is too large'},
{'errBaseTypeMustBeOrdinal': 'base type of a set must be an ordinal'},
{'errInheritanceOnlyWithNonFinalObjects':
  'inheritance only works with non-final objects'},
{'errInheritanceOnlyWithEnums': 'inheritance only works with an enum'},
{'errIllegalRecursionInTypeX': "illegal recursion in type '$1'"},
{'errCannotInstantiateX': "cannot instantiate: '$1'"},
{'errExprHasNoAddress': "expression has no address"},
{'errVarForOutParamNeeded':
  "for a 'var' type a variable needs to be passed"},
{'errPureTypeMismatch': 'type mismatch'},
{'errTypeMismatch': 'type mismatch: got ('},
{'errButExpected': 'but expected one of: '},
{'errButExpectedX': "but expected '$1'"},
{'errAmbigiousCallXYZ': 'ambigious call; both $1 and $2 match for: $3'},
{'errWrongNumberOfTypeParams': 'wrong number of type parameters'},
{'errOutParamNoDefaultValue': 'out parameters cannot have default values'},
{'errInlineProcHasNoAddress': 'an inline proc has no address'},
{'errXCannotBeInParamDecl': '$1 cannot be declared in parameter declaration'},
{'errPragmaOnlyInHeaderOfProc':
  'pragmas are only in the header of a proc allowed'},
{'errImportedProcCannotHaveImpl':
  'an imported proc cannot have an implementation'},
{'errImplOfXNotAllowed': "implementation of '$1' is not allowed here"},
{'errImplOfXexpected': "implementation of '$1' expected"},
{'errDiscardValue': 'value returned by statement has to be discarded'},
{'errInvalidDiscard': 'statement returns no value that can be discarded'},
{'errUnknownPrecedence':
  "unknown precedence for operator; use 'infix: prec' pragma"},
{'errIllegalConvFromXtoY': 'conversion from $1 to $2 is invalid'},
{'errTypeMismatchExpectedXGotY': "type mismatch: expected '$1', but got '$2'"},
{'errCannotBindXTwice': "cannot bind parameter '$1' twice"},
{'errInvalidOrderInEnumX': "invalid order in enum '$1'"},
{'errEnumXHasWholes': "enum '$1' has wholes"},
{'errExceptExpected': "'except' or 'finally' expected"},
{'errInvalidTry': "after catch all 'except' or 'finally' no section may follow"},
{'errEofExpectedButXFound': "end of file expected, but found token '$1'"},
{'errOptionExpected': "option expected, but found '$1'"},
{'errCannotEvaluateForwardConst': 'cannot evaluate forwarded constant'},
{'errXisNoLabel': "'$1' is not a label"},
{'errXNeedsConcreteType': "'$1' needs to be of a non-generic type"},
{'errNotAllCasesCovered': 'not all cases are covered'},
{'errStringRange': 'string range in case statement not allowed'},
{'errUnkownSubstitionVar': "unknown substitution variable: '$1'"},
{'errComplexStmtRequiresInd': 'complex statement requires indentation'},
{'errXisNotCallable': "'$1' is not callable"},
{'errNoPragmasAllowedForX': 'no pragmas allowed for $1'},
{'errNoGenericParamsAllowedForX': 'no generic parameters allowed for $1'},
{'errInvalidParamKindX': "invalid param kind: '$1'"},
{'errDefaultArgumentInvalid': 'default argument invalid'},
{'errNamedParamHasToBeIdent': 'named parameter has to be an identifier'},
{'errNoReturnTypeForX': 'no return type for $1 allowed'},
{'errConvNeedsOneArg': 'a type conversion needs exactly one argument'},
{'errInvalidPragmaX': 'invalid pragma: $1'},
{'errXNotAllowedHere': '$1 here not allowed'},
{'errInvalidControlFlowX': 'invalid control flow: $1'},
{'errATypeHasNoValue': 'a type has no value'},
{'errXisNoType': "'$1' is no type"},
{'errCircumNeedsPointer': "'^' needs a pointer or reference type"},
{'errInvalidContextForBuiltinX': "invalid context for builtin '$1'"},
{'errInvalidExpression': 'invalid expression'},
{'errInvalidExpressionX': "invalid expression: '$1'"},
{'errEnumHasNoValueX': "enum has no value '$1'"},
{'errNamedExprExpected': 'named expression expected'},
{'errNamedExprNotAllowed': 'named expression here not allowed'},
{'errXExpectsOneTypeParam': "'$1' expects one type parameter"},
{'errArrayExpectsTwoTypeParams': 'array expects two type parameters'},
{'errInvalidVisibilityX': "invalid invisibility: '$1'"},
{'errInitHereNotAllowed': 'initialization here not allowed'},
{'errXCannotBeAssignedTo': "'$1' cannot be assigned to"},
{'errIteratorNotAllowed':
  "iterators can only be defined at the module's top level"},
{'errIteratorNeedsImplementation': 'iterator needs an implementation'},
{'errIteratorNeedsReturnType': 'iterator needs a return type'},
{'errInvalidCommandX': "invalid command: '$1'"},
{'errXOnlyAtModuleScope': "'$1' is only allowed at top level"},
{'errTypeXNeedsImplementation': "type '$1' needs an implementation"},
{'errTemplateInstantiationTooNested': 'template instantiation too nested'},
{'errInstantiationFrom': 'instantiation from here'},
{'errInvalidIndexValueForTuple': 'invalid index value for tuple subscript'},
{'errCommandExpectsFilename': 'command expects a filename argument'},
{'errXExpected': "'$1' expected"},
{'errInvalidSectionStart': 'invalid section start'},
{'errGridTableNotImplemented': 'grid table is not implemented'},
{'errGeneralParseError': 'general parse error'},
{'errNewSectionExpected': 'new section expected'},
{'errWhitespaceExpected': "whitespace expected, got '$1'"},
{'errXisNoValidIndexFile': "'$1' is no valid index file"},
{'errCannotRenderX': "cannot render reStructuredText element '$1'"},
{'errVarVarTypeNotAllowed': "type 'var var' is not allowed"},
{'errIsExpectsTwoArguments': "'is' expects two arguments"},
{'errIsExpectsObjectTypes': "'is' expects object types"},
{'errXcanNeverBeOfThisSubtype': "'$1' can never be of this subtype"},
{'errTooManyIterations': "interpretation requires too many iterations"},
{'errCannotInterpretNodeX': "cannot interpret node kind '$1'"},
{'errFieldXNotFound': "field '$1' cannot be found"},
{'errInvalidConversionFromTypeX': "invalid conversion from type '$1'"},
{'errAssertionFailed': "assertion failed"},
{'errCannotGenerateCodeForX': "cannot generate code for '$1'"},
{'errXNeedsReturnType': "converter needs return type"},
{'errXRequiresOneArgument': "converter requires one parameter"},
{'errUnhandledExceptionX': "unhandled exception: $1"},
{'errCyclicTree': "macro returned a cyclic abstract syntax tree"},

# user error message:
{'errUser': '$1'},

# warnings:
{'warnCannotOpenFile': "cannot open '$1'"},
{'warnOctalEscape':
  'octal escape sequences do not exist; leading zero is ignored'},
{'warnXIsNeverRead': "'$1' is never read"},
{'warnXmightNotBeenInit': "'$1' might not have been initialized"},
{'warnCannotWriteMO2': "cannot write file '$1'"},
{'warnCannotReadMO2': "cannot read file '$1'"},
{'warnDeprecated': "'$1' is deprecated"},
{'warnSmallLshouldNotBeUsed':
  "'l' should not be used as an identifier; may look like '1' (one)"},
{'warnUnknownMagic': "unknown magic '$1' might crash the compiler"},
{'warnRedefinitionOfLabel': "redefinition of label '$1'"},
{'warnUnknownSubstitutionX': "unknown substitution '$1'"},
{'warnLanguageXNotSupported': "language '$1' not supported"},
{'warnCommentXIgnored': "comment '$1' ignored"},
# user warning message:
{'warnUser': '$1'},

# hints:
{'hintSuccess': 'operation successful'},
{'hintSuccessX': 'operation successful ($1 lines compiled; $2 sec total)'},
{'hintLineTooLong': 'line too long'},
{'hintXDeclaredButNotUsed': "'$1' is declared but not used"},
{'hintConvToBaseNotNeeded': 'conversion to base object is not needed'},
{'hintConvFromXtoItselfNotNeeded': 'conversion from $1 to itself is pointless'},
{'hintExprAlwaysX': "expression evaluates always to '$1'"},
{'hintQuitCalled': "quit() called"},
{'hintProcessing': "processing $1"},
{'hintCodeBegin': "generated code listing:"},
{'hintCodeEnd': "end of listing"},
{'hintConf': "used config file '$1'"},

# user hint message:
{'hintUser': '$1'}
]
