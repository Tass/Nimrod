module ::= ([COMMENT] [SAD] stmt)*

comma ::= ',' [COMMENT] [IND]
operator ::= OP0 | OR | XOR | AND | OP3 | OP4 | OP5 | OP6 | OP7
           | 'is' | 'isnot' | 'in' | 'notin'
           | 'div' | 'mod' | 'shl' | 'shr' | 'not'

prefixOperator ::= OP0 | OP3 | OP4 | OP5 | OP6 | OP7 | 'not'

optInd ::= [COMMENT] [IND]


lowestExpr ::= orExpr (OP0 optInd orExpr)*
orExpr ::= andExpr (OR | 'xor' optInd andExpr)*
andExpr ::= cmpExpr ('and' optInd cmpExpr)*
cmpExpr ::= ampExpr (OP3 | 'is' | 'isnot' | 'in' | 'notin' optInd ampExpr)*
ampExpr ::= plusExpr (OP4 optInd plusExpr)*
plusExpr ::= mulExpr (OP5 optInd mulExpr)*
mulExpr ::= dollarExpr (OP6 | 'div' | 'mod' | 'shl' | 'shr' optInd dollarExpr)*
dollarExpr ::= primary (OP7 optInd primary)*

namedTypeOrExpr ::=
  '..' [expr]
  | expr ['=' (expr ['..' expr] | typeDescK | '..' [expr]) | '..' [expr]]
  | typeDescK

castExpr ::= 'cast' '[' optInd typeDesc [SAD] ']' '(' optInd expr [SAD] ')'
addrExpr ::= 'addr' '(' optInd expr ')'
symbol ::= '`' (KEYWORD | IDENT | operator | '(' ')'
               | '[' ']' | '=' | literal)+ '`'
         | IDENT
primary ::= (prefixOperator optInd)* (symbol | constructor |
                                             | castExpr | addrExpr) (
               '.' optInd symbol
             | '(' optInd namedExprList [SAD] ')'
             | '[' optInd
               [namedTypeOrExpr (comma namedTypeOrExpr)* [comma]]
               [SAD] ']'
             | '^'
             | pragma)*

literal ::= INT_LIT | INT8_LIT | INT16_LIT | INT32_LIT | INT64_LIT
          | FLOAT_LIT | FLOAT32_LIT | FLOAT64_LIT
          | STR_LIT | RSTR_LIT | TRIPLESTR_LIT
          | CHAR_LIT | RCHAR_LIT
          | NIL

constructor ::= literal
          | '[' optInd colonExprList [SAD] ']'
          | '{' optInd sliceExprList [SAD] '}'
          | '(' optInd colonExprList [SAD] ')'

colonExpr ::= expr [':' expr]
colonExprList ::= [colonExpr (comma colonExpr)* [comma]]

namedExpr ::= expr ['=' expr]
namedExprList ::= [namedExpr (comma namedExpr)* [comma]]

sliceExpr ::= expr ['..' expr]
sliceExprList ::= [sliceExpr (comma sliceExpr)* [comma]]

anonymousProc ::= 'lambda' paramList [pragma] '=' stmt
expr ::= lowestExpr
     | anonymousProc
     | 'if' expr ':' expr ('elif' expr ':' expr)* 'else' ':' expr

namedTypeDesc ::= typeDescK | expr ['=' (typeDescK | expr)]
namedTypeDescList ::= [namedTypeDesc (comma namedTypeDesc)* [comma]]

qualifiedIdent ::= symbol ['.' symbol]

typeDescK ::= 'var' typeDesc
            | 'ref' typeDesc
            | 'ptr' typeDesc
            | 'type' expr
            | 'tuple' tupleDesc
            | 'proc' paramList [pragma]

typeDesc ::= typeDescK | primary

macroStmt ::= ':' [stmt] ('of' [sliceExprList] ':' stmt
                         |'elif' expr ':' stmt
                         |'except' exceptList ':' stmt )*
                         ['else' ':' stmt]

simpleStmt ::= returnStmt
           | yieldStmt
           | discardStmt
           | raiseStmt
           | breakStmt
           | continueStmt
           | pragma
           | importStmt
           | fromStmt
           | includeStmt
           | exprStmt
complexStmt ::= ifStmt | whileStmt | caseStmt | tryStmt | forStmt
                 | blockStmt | asmStmt
                 | procDecl | iteratorDecl | macroDecl | templateDecl
                 | constSection | typeSection | whenStmt | varSection

indPush ::= IND # and push indentation onto the stack
indPop ::= # pop indentation from the stack

stmt ::= simpleStmt [SAD]
 | indPush (complexStmt | simpleStmt)
  ([SAD] (complexStmt | simpleStmt))*
   DED indPop

exprStmt ::= lowestExpr ['=' expr | [expr (comma expr)*] [macroStmt]]
returnStmt ::= 'return' [expr]
yieldStmt ::= 'yield' expr
discardStmt ::= 'discard' expr
raiseStmt ::= 'raise' [expr]
breakStmt ::= 'break' [symbol]
continueStmt ::= 'continue'
ifStmt ::= 'if' expr ':' stmt ('elif' expr ':' stmt)* ['else' ':' stmt]
whenStmt ::= 'when' expr ':' stmt ('elif' expr ':' stmt)* ['else' ':' stmt]
caseStmt ::= 'case' expr [':'] ('of' sliceExprList ':' stmt)*
                               ('elif' expr ':' stmt)*
                               ['else' ':' stmt]
whileStmt ::= 'while' expr ':' stmt
forStmt ::= 'for' symbol (comma symbol)* 'in' expr ['..' expr] ':' stmt
exceptList ::= [qualifiedIdent (comma qualifiedIdent)*]

tryStmt ::= 'try' ':' stmt
           ('except' exceptList ':' stmt)*
           ['finally' ':' stmt]
asmStmt ::= 'asm' [pragma] (STR_LIT | RSTR_LIT | TRIPLESTR_LIT)
blockStmt ::= 'block' [symbol] ':' stmt
filename ::= symbol | STR_LIT | RSTR_LIT | TRIPLESTR_LIT
importStmt ::= 'import' filename (comma filename)*
includeStmt ::= 'include' filename (comma filename)*
fromStmt ::= 'from' filename 'import' symbol (comma symbol)*

pragma ::= '{.' optInd (colonExpr [comma])* [SAD] ('.}' | '}')

param ::= symbol (comma symbol)* ':' typeDesc
paramList ::= ['(' [param (comma param)*] [SAD] ')'] [':' typeDesc]

genericParam ::= symbol [':' typeDesc]
genericParams ::= '[' genericParam (comma genericParam)* [SAD] ']'

procDecl ::= 'proc' symbol ['*'] [genericParams] paramList [pragma]
             ['=' stmt]
macroDecl ::= 'macro' symbol ['*'] [genericParams] paramList [pragma]
             ['=' stmt]
iteratorDecl ::= 'iterator' symbol ['*'] [genericParams] paramList [pragma]
             ['=' stmt]
templateDecl ::= 'template' symbol ['*'] [genericParams] paramList [pragma]
             ['=' stmt]

colonAndEquals ::= [':' typeDesc] '=' expr

constDecl ::= symbol ['*'] [pragma] colonAndEquals [COMMENT | IND COMMENT]
            | COMMENT
constSection ::= 'const' indPush constDecl (SAD constDecl)* DED indPop
typeDef ::= typeDesc | objectDef | enumDef

objectField ::= symbol ['*'] [pragma]
objectIdentPart ::=
  objectField (comma objectField)* ':' typeDesc [COMMENT|IND COMMENT]

objectWhen ::= 'when' expr ':' [COMMENT] objectPart
              ('elif' expr ':' [COMMENT] objectPart)*
              ['else' ':' [COMMENT] objectPart]
objectCase ::= 'case' expr ':' typeDesc [COMMENT]
              ('of' sliceExprList ':' [COMMENT] objectPart)*
              ['else' ':' [COMMENT] objectPart]

objectPart ::= objectWhen | objectCase | objectIdentPart | 'nil'
             | indPush objectPart (SAD objectPart)* DED indPop
tupleDesc ::= '[' optInd [param (comma param)*] [SAD] ']'

objectDef ::= 'object' [pragma] ['of' typeDesc] objectPart
enumField ::= symbol ['=' expr]
enumDef ::= 'enum' ['of' typeDesc] (enumField [comma] [COMMENT | IND COMMENT])+

typeDecl ::= COMMENT
           | symbol ['*'] [genericParams] ['=' typeDef] [COMMENT | IND COMMENT]

typeSection ::= 'type' indPush typeDecl (SAD typeDecl)* DED indPop

colonOrEquals ::= ':' typeDesc ['=' expr] | '=' expr
varField ::= symbol ['*'] [pragma]
varPart ::= symbol (comma symbol)* colonOrEquals [COMMENT | IND COMMENT]
varSection ::= 'var' (varPart
                   | indPush (COMMENT|varPart)
                     (SAD (COMMENT|varPart))* DED indPop)
