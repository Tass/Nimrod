module ::= ([COMMENT] [SAD] stmt)*

comma ::= ',' [COMMENT] [IND]
operator ::= OP0 | OR | XOR | AND | OP3 | OP4 | OP5 | IS | ISNOT | IN | NOTIN
           | OP6 | DIV | MOD | SHL | SHR | OP7 | NOT

prefixOperator ::= OP0 | OP3 | OP4 | OP5 | OP6 | OP7 | NOT

optInd ::= [COMMENT] [IND]


lowestExpr ::= orExpr ( OP0 optInd orExpr )*
orExpr ::= andExpr ( OR | XOR optInd andExpr )*
andExpr ::= cmpExpr ( AND  optInd cmpExpr )*
cmpExpr ::= ampExpr ( OP3 | IS | ISNOT | IN | NOTIN optInd ampExpr )*
ampExpr ::= plusExpr ( OP4 optInd plusExpr )*
plusExpr ::= mulExpr ( OP5 optInd mulExpr )*
mulExpr ::= dollarExpr ( OP6 | DIV | MOD | SHL | SHR optInd dollarExpr )*
dollarExpr ::= primary ( OP7 optInd primary )*

namedTypeOrExpr ::=
  DOTDOT [expr]
  | expr [EQUALS (expr [DOTDOT expr] | typeDescK | DOTDOT [expr] )
                 | DOTDOT [expr]]
  | typeDescK

castExpr ::= CAST BRACKET_LE optInd typeDesc BRACKERT_RI
                  PAR_LE optInd expr PAR_RI
addrExpr ::= ADDR PAR_LE optInd expr PAR_RI
symbol ::= ACC (KEYWORD | IDENT | operator | PAR_LE PAR_RI
               | BRACKET_LE BRACKET_RI | EQUALS | literal )+ ACC
         | IDENT
primary ::= ( prefixOperator optInd )* ( symbol | constructor |
                                                | castExpr | addrExpr ) (
               DOT optInd symbol
             #| CURLY_LE namedTypeDescList CURLY_RI
             | PAR_LE optInd namedExprList PAR_RI
             | BRACKET_LE optInd
               [ namedTypeOrExpr (comma namedTypeOrExpr)* [comma] ]
               BRACKET_RI
             | CIRCUM
             | pragma )*

literal ::= INT_LIT | INT8_LIT | INT16_LIT | INT32_LIT | INT64_LIT
          | FLOAT_LIT | FLOAT32_LIT | FLOAT64_LIT
          | STR_LIT | RSTR_LIT | TRIPLESTR_LIT
          | CHAR_LIT | RCHAR_LIT
          | NIL

constructor ::= literal
          | BRACKET_LE optInd colonExprList BRACKET_RI # []-Constructor
          | CURLY_LE optInd sliceExprList CURLY_RI     # {}-Constructor
          | PAR_LE optInd colonExprList PAR_RI         # ()-Constructor

exprList ::= [ expr (comma expr)* [comma] ]

colonExpr ::= expr [COLON expr]
colonExprList ::= [ colonExpr (comma colonExpr)* [comma] ]

namedExpr ::= expr [EQUALS expr] # actually this is symbol EQUALS expr|expr
namedExprList ::= [ namedExpr (comma namedExpr)* [comma] ]

sliceExpr ::= expr [ DOTDOT expr ]
sliceExprList ::= [ sliceExpr (comma sliceExpr)* [comma] ]

anonymousProc ::= LAMBDA paramList [pragma] EQUALS stmt
expr ::= lowestExpr
     | anonymousProc
     | IF expr COLON expr
       (ELIF expr COLON expr)*
       ELSE COLON expr

namedTypeDesc ::= typeDescK | expr [EQUALS (typeDescK | expr)]
namedTypeDescList ::= [ namedTypeDesc (comma namedTypeDesc)* [comma] ]

qualifiedIdent ::= symbol [ DOT symbol ]

typeDescK ::= VAR typeDesc
            | REF typeDesc
            | PTR typeDesc
            | TYPE expr
            | TUPLE tupleDesc
            | PROC paramList [pragma]

typeDesc ::= typeDescK | primary

optSemicolon ::= [SEMICOLON]

macroStmt ::= COLON [stmt] (OF [sliceExprList] COLON stmt
                           | ELIF expr COLON stmt
                           | EXCEPT exceptList COLON stmt )*
                           [ELSE COLON stmt]

simpleStmt ::= returnStmt
           | yieldStmt
           | discardStmt
           | raiseStmt
           | breakStmt
           | continueStmt
           | pragma
           | importStmt
           | fromStmt
           | includeStmt
           | exprStmt
complexStmt ::= ifStmt | whileStmt | caseStmt | tryStmt | forStmt
                 | blockStmt | asmStmt
                 | procDecl | iteratorDecl | macroDecl | templateDecl
                 | constSection | typeSection | whenStmt | varSection

indPush ::= IND # push
stmt ::= simpleStmt [SAD]
 | indPush (complexStmt | simpleStmt)
  ([SAD] (complexStmt | simpleStmt) )*
   DED

exprStmt ::= lowestExpr [EQUALS expr | [expr (comma expr)* [comma]] [macroStmt]]
returnStmt ::= RETURN [expr]
yieldStmt ::= YIELD expr
discardStmt ::= DISCARD expr
raiseStmt ::= RAISE [expr]
breakStmt ::= BREAK [symbol]
continueStmt ::= CONTINUE
ifStmt ::= IF expr COLON stmt (ELIF expr COLON stmt)* [ELSE COLON stmt]
whenStmt ::= WHEN expr COLON stmt (ELIF expr COLON stmt)* [ELSE COLON stmt]
caseStmt ::= CASE expr (OF sliceExprList COLON stmt)*
                       (ELIF expr COLON stmt)*
                       [ELSE COLON stmt]
whileStmt ::= WHILE expr COLON stmt
forStmt ::= FOR symbol (comma symbol)* [comma] IN expr [DOTDOT expr] COLON stmt
exceptList ::= [qualifiedIdent (comma qualifiedIdent)* [comma]]

tryStmt ::= TRY COLON stmt
          (EXCEPT exceptList COLON stmt)*
          [FINALLY COLON stmt]
asmStmt ::= ASM [pragma] (STR_LIT | RSTR_LIT | TRIPLESTR_LIT)
blockStmt ::= BLOCK [symbol] COLON stmt
filename ::= symbol | STR_LIT | RSTR_LIT | TRIPLESTR_LIT
importStmt ::= IMPORT filename (comma filename)* [comma]
includeStmt ::= INCLUDE filename (comma filename)* [comma]
fromStmt ::= FROM filename IMPORT symbol (comma symbol)* [comma]

pragma ::= CURLYDOT_LE colonExprList (CURLYDOT_RI | CURLY_RI)

param ::= symbol (comma symbol)* [comma] COLON typeDesc
paramList ::= [PAR_LE [param (comma param)* [comma]] PAR_RI] [COLON typeDesc]

genericParams ::= BRACKET_LE (symbol [EQUALS typeDesc] )* BRACKET_RI

procDecl ::= PROC symbol ["*"] [genericParams]
             paramList [pragma]
             [EQUALS stmt]
macroDecl ::= MACRO symbol ["*"] [genericParams] paramList [pragma]
             [EQUALS stmt]
iteratorDecl ::= ITERATOR symbol ["*"] [genericParams] paramList [pragma]
             [EQUALS stmt]
templateDecl ::= TEMPLATE symbol ["*"] [genericParams] paramList [pragma]
             [EQUALS stmt]

colonAndEquals ::= [COLON typeDesc] EQUALS expr

constDecl ::= symbol ["*"] [pragma] colonAndEquals [COMMENT | IND COMMENT]
            | COMMENT
constSection ::= CONST indPush constDecl (SAD constDecl)* DED
typeDef ::= typeDesc | objectDef | enumDef

objectField ::= symbol ["*"] [pragma]
objectIdentPart ::=
  objectField (comma objectField)* [comma] COLON typeDesc [COMMENT|IND COMMENT]

objectWhen ::= WHEN expr COLON [COMMENT] objectPart
              (ELIF expr COLON [COMMENT] objectPart)*
              [ELSE COLON [COMMENT] objectPart]
objectCase ::= CASE expr COLON typeDesc [COMMENT]
              (OF sliceExprList COLON [COMMENT] objectPart)*
              [ELSE COLON [COMMENT] objectPart]

objectPart ::= objectWhen | objectCase | objectIdentPart | NIL
             | indPush objectPart (SAD objectPart)* DED
tupleDesc ::= BRACKET_LE optInd [param (comma param)* [comma]] BRACKET_RI

objectDef ::= OBJECT [pragma] [OF typeDesc] objectPart
enumField ::= symbol [EQUALS expr]
enumDef ::= ENUM [OF typeDesc] (enumField [comma | COMMENT | IND COMMENT])+

typeDecl ::= COMMENT
           | symbol ["*"] [genericParams] [EQUALS typeDef] [COMMENT | IND COMMENT]

typeSection ::= TYPE indPush typeDecl (SAD typeDecl)* DED

colonOrEquals ::= COLON typeDesc [EQUALS expr] | EQUALS expr
varField ::= symbol ["*"] [pragma]
varPart ::= symbol (comma symbol)* [comma] colonOrEquals [COMMENT | IND COMMENT]
varSection ::= VAR (varPart
                   | indPush (COMMENT|varPart) (SAD (COMMENT|varPart))* DED)
