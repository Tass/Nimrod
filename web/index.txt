====
Home
====

  The most important thing in the programming language is the name. A language
  will not succeed without a good name. I have recently invented a very good
  name and now I am looking for a suitable language.
  -- D. E. Knuth


**Nimrod combines Lisp's power with Python's readability and C's performance.**

Welcome to Nimrod
-----------------

**Nimrod** is a statically typed, imperative programming language that tries to
give the programmer ultimate power without compromises on runtime efficiency. 
This means it focuses on compile-time mechanisms in all their
various forms. Beneath a nice infix/indentation based syntax with a 
powerful (AST based, hygienic) macro system lies a semantic model that supports 
a soft realtime GC on thread local heaps. Asynchronous message passing is used 
between threads, so no "stop the world" mechanism is necessary. An unsafe 
shared memory heap is also provided for the increased efficiency that results 
from that model.


.. container:: snippet
  *Nimrod looks like this:*
  
  .. code-block:: nimrod
    import strutils
    
    # Prints the maximum integer from a list of integers
    # delimited by whitespace read from stdin.
    let tokens = stdin.readLine.split
    echo tokens.each(parseInt).max, " is the maximum."


Nimrod is efficient
===================

* Native code generation (currently via compilation to C), not dependent on a
  virtual machine: **Nimrod produces small executables without dependencies
  for easy redistribution.**
* A fast **non-tracing** garbage collector that supports soft 
  real-time systems (like games).
* System programming features: Ability to manage your own memory and access the
  hardware directly. Pointers to garbage collected memory are distinguished
  from pointers to manually managed memory.
* Zero-overhead iterators.
* Cross-module inlining.
* Dynamic method binding with inlining and without virtual method table.
* Compile time evaluation of user-defined functions.
* Whole program dead code elimination: Only *used functions* are included in 
  the executable.
* Value-based datatypes: For instance, objects and arrays can be allocated on 
  the stack.


Nimrod is expressive
====================

* **The Nimrod compiler and all of the standard library are implemented in 
  Nimrod.**
* Built-in high level datatypes: strings, sets, sequences, etc.
* Modern type system with local type inference, tuples, variants, 
  generics, etc.
* User-defineable operators; code with new operators is often easier to read
  than code which overloads built-in operators. For example, a 
  ``=~`` operator is defined in the ``re`` module.
* Macros can modify the abstract syntax tree at compile time.


Nimrod is elegant
=================

* Macros can use the imperative paradigm to construct parse trees. Nimrod
  does not require a different coding style for meta programming.
* Macros cannot change Nimrod's syntax because there is no need for it. 
  Nimrod's syntax is flexible enough.
* Statements are grouped by indentation but can span multiple lines.
  Indentation must not contain tabulators so the compiler always sees
  the code the same way as you do.


Nimrod plays nice with others
=============================

* The Nimrod Compiler runs on Windows, Linux, BSD and Mac OS X.
  Porting to other platforms is easy.
* **The Nimrod Compiler can also generate C++ or Objective C for easier
  interfacing.**
* There are lots of bindings: for example, bindings to GTK2, the Windows API, 
  the POSIX API, OpenGL, SDL, Cario, Python, Lua, TCL, X11, libzip, PCRE, 
  libcurl, mySQL and SQLite are included in the standard distribution.
* A C to Nimrod conversion utility: New bindings to C libraries are easily 
  generated by ``c2nim``.


Roadmap to 1.0
==============

Version 0.9.2
  * overloading based on ASTs (like already possible for term rewriting macros)
  * better interaction between macros, templates and overloading
  * the symbol binding rules for generics and templates may change again

Version 0.9.x
  * message passing performance will be greatly improved
  * the syntactic distinction between statements and expressions will be
    removed
  * the need for forward declarations may be removed
