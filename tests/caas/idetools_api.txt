idetools_api.nim
> c
SuccessX
> idetools --track:$TESTNIM,4,11 --def
def\tskType\tsystem.TFile\tTFile
> idetools --track:$TESTNIM,5,7 --def
def\tskProc\tsystem.Open\tproc \(var TFile, string, TFileMode, int\): bool
> idetools --track:$TESTNIM,5,21 --def
def\tskProc\tsystem.\&\tproc \(string, string\): string\{.noSideEffect.\}
> idetools --track:$TESTNIM,5,38 --def
def\tskEnumField\tsystem.TFileMode.fmWrite\tTFileMode
> idetools --track:$TESTNIM,7,6 --def
def\tskProc\tsystem.Close\tproc \(TFile\)
> idetools --track:$TESTNIM,12,23 --def
def\tskIterator\tunicode.runes\titerator \(string\): TRune
> idetools --track:$TESTNIM,12,15 --def
def\tskTemplate\tsequtils.toSeq\tproc \(expr\): expr
> idetools --track:$TESTNIM,15,7 --def

# ProcRun mode will fail the next line, because the type is returned empty.
def\tskConst\t$MODULE.SOME_SEQUENCE\tseq\[int\]\t
> idetools --track:$TESTNIM,15,23 --def
def\tskProc\tsystem.@\tproc \(array\[IDX, T\]\): seq\[T\]\{.noSideEffect.\}
> idetools --track:$TESTNIM,17,3 --def

# ProcRun mode will fail the next line, because the type is returned empty.
def\tskType\t$MODULE.bad_string\tbad_string\t
> idetools --track:$TESTNIM,11,24 --def
def\tskParam\t$MODULE.test_iterators.filename\tstring
> idetools --track:$TESTNIM,6,5 --def
def\tskVar\t$MODULE.test_enums.o\tTFile
> idetools --track:$TESTNIM,12,34 --def
def\tskLet\t$MODULE.test_iterators.input\tTaintedString
> idetools --track:$TESTNIM,13,35 --def
def\tskForVar\t$MODULE.test_iterators.letter\tTRune
> idetools --track:$TESTNIM,23,3 --def
def\tskResult\t$MODULE.adder.result\tint
> idetools --track:$TESTNIM,19,6 --def

# ProcRun mode will fail the next line, because the type is returned empty.
def\tskField\t$MODULE.TPerson.name\tbad_string\t

> idetools --track:$TESTNIM,43,7 --def
def\tskMethod\t$MODULE.eval\tproc \(PPlusExpr\): int\t
